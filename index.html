<!DOCTYPE html>
<html>
  <head>
    <title>Sea of logs</title>
    <style type="text/css">
      html, body, iframe {width: 100%; height: 100%; overflow: hidden; margin: 0; border: none;}
    </style>
    <script>
      window.onload = (_) => {
        const params = new URLSearchParams(window.location.search);
        const target = location.origin;
        const logs = [...document.getElementsByTagName("body")[0].childNodes]
          .filter((c) => c.nodeType == Node.COMMENT_NODE)
          .reverse()[0].data;
        document.getElementsByTagName("iframe")[0].contentWindow.init(params, target, logs);
      }

      window.onmessage = (e) => {
        if (e.origin != document.location.origin) return;
        const url = window.location.href.replace(/\?.*$/, "") + (e.data.length == 0 ? "" : "?" + e.data);
        history.replaceState(null, null, url);
      }
  </script>
  </head>
<body>
  <iframe sandbox="allow-scripts allow-same-origin" srcdoc="&lt;!DOCTYPE html&gt;
    &lt;style type=&apos;text/css&apos;&gt;html {
    height: 100%;
    width: 100%;
    margin: 0;
  }

  body {
    margin: 0;
    height: 100%;
    width: 100%;
    background-color: white;
    color: black;
  }

  table {
    height: 100%;
    width: 100%;
    border-collapse: collapse;
  }

  #left {
    position: fixed;
    width: 20%;
    height: 100%;
    background-color: lightgray;
    vertical-align: top;
    overflow: hidden;
    white-space: nowrap;
  }

  #perf {
    display: none;
    font-size: small;
  }

  #right {
    margin: 0;
    margin-left: 20%;
    width: 80%;
    font-size: small;
    padding: 0;
  }

  #title a {
    color: black;
    text-decoration: none;
  }

  #title a:visited {
    color: black;
  }

  .message,
  .background {
    margin: 0.5ex;
  }

  .messagetext {
    cursor: grab;
  }

  .messagetime {
    cursor: zoom-in;
  }

  #backgrounds,
  #messages {
    position: absolute;
    width: 80%;
    height: 100%;
    margin: 0;
  }

  #connectors {
    position: absolute;
    width: 80%;
    height: 100%;
    margin: 0;
  }

  #left textarea {
    font-family: sans-serif;
    width: 92%;
  }

  .messagetime,
  .logcount {
    font-size: xx-small;
    color: gray;
    font-family: monospace;
  }

  .error {
    color: red;
    background-color: #500000;
    border: solid thin red;
    margin: 0.5ex 1em 0.5ex 0.2em;
    font-size: small;
    padding: 0.5ex;
  }

  #popup {
    font-size: x-small;
    font-family: monospace;
    position: absolute;
    white-space: pre;
    display: none;
    max-width: 50em;
    max-height: 20em;
    overflow: auto;
    border: solid thin black;
    background-color: #F0F0F0;
  }

  #menu {
    position: fixed;
    display: none;
  }

  #menu select::-webkit-scrollbar {
    display: none;
  }

  #menu select::-moz-scrollbar {
    display: none;
  }

  #menu select::-o-scrollbar {
    display: none;
  }

  #menu select::-google-ms-scrollbar {
    display: none;
  }

  #menu select::-khtml-scrollbar {
    display: none;
  }

  #menu #autocomplete {
    font-size: small;
    background-color: #f0f0f0;
    border: solid thin black;
    padding: 0.2ex;
    z-index: 100;
    box-shadow: 0 0 1ex 1ex black;
  }

  .autocomplete_name {
    padding-right: 1em;
  }

  .autocomplete_hint {
    font-style: italic;
    color: darkgreen;
  }

  #load {
    opacity: 0;
    position: absolute;
    z-index: -1;
  }

  #loadbutton {
    font-size: smaller;
    cursor: arrow;
    background-color: #f0f0f0;
    padding: 0.2ex;
    border: solid thin black;
    border-radius: 0.5ex;
  }

  #loadbutton:hover {
    background-color: #f0f0FF;
  }
  &lt;/style&gt;
    &lt;script&gt;&apos;use strict&apos;;

// How does one host the seaoflogs library? It is designed to run in a sandboxed
// iframe which has seaoflogs.js and seaoflogs.css and an empty body, and which has
// only a small number of connection-points to the host outside that sandbox:
// (1) When the user interacts with seaoflogs to alter the drillstate, seaoflogs wants
// to store the current drillstate in the browser&apos;s url, but being in a sandbox it&apos;s
// not allowed to - hence it uses postMessage to request its host to alter the url;
// (2) When seaoflogs first starts up it must be told the initial url drillstate,
// and the target to which send updates via postMessage, and must be given any log
// content with which to populate itself initially. This is done either by having
// a same-origin host invoke its .init(params, target, logs) method, or by specifying
// the three declaratively in three tags &lt;meta name=&quot;seaoflogs_params&quot; content=&quot;...&quot;/&gt;
// and name=&quot;seaoflogs_target&quot; and &quot;seaoflogs_logs&quot;. The tag route is appealing
// because the sandbox doesn&apos;t even need any same-origin permissions.


// ===================================================================
// ===================================================================
// ===================================================================
// ===================================================================
// GLOBAL MUTABLE STATE
// In addition to these variables, the URL query params also provide
// one state field &apos;details&apos; used by render_popup to know the details
// function.
// ===================================================================
// ===================================================================
// ===================================================================
// ===================================================================

/** a global list of all messages from all known logs, even if they&apos;re hidden (unchecked).
 * It is initially empty; it is only ever appended, upon window.onload and clicking the
 * &quot;load&quot; button.
 */
let global_messages = [];

/** a count of how many messages are in each named log. */
let global_log_counts = {};

/** global autocomplete dictionary, constructed by control_handler after re-rendering
 * current messages. It is a map {member_name -&gt; {hint:string, nested:dictionary}}
 * We treat an array [1,2,3] as a dictionary with a single member {ELEMENT -&gt; [element_types]}
 */
let global_current_dictionary = {};

/** this is a timer to debounce edits and resizes, used by control_handler
 */
let global_debounce_timeout = null;

/** resize_expected_height is the last height to have been computed for the messages div;
 * control_handler detects upon scroll that if the current height is different, then all
 * svg lines will have to be recomputed
 */
let global_resize_expected_height = null;

/** If a popup is up, this is its index (into the unfiltered/unsorted global_messages)
 */
let global_popup_message_index = null;

/** When we want to alter the url query params, we&apos;ll do it by postMessage to this
 * target. Initialized by the &apos;init&apos; method.
 */
let global_target = null;

// ===================================================================
// ===================================================================
// ===================================================================
// ===================================================================
// ENTRY POINTS
// ===================================================================
// ===================================================================
// ===================================================================
// ===================================================================

window.onload = (_) =&gt; {
  const params = document.getElementsByTagName(&quot;meta&quot;)[&quot;seaoflogs_params&quot;]?.content;
  const target = document.getElementsByTagName(&quot;meta&quot;)[&quot;seaoflogs_target&quot;]?.content;
  const logs = document.getElementsByTagName(&quot;meta&quot;)[&quot;seaoflogs_logs&quot;]?.content;
  if (params != null || target != null || logs != null) {
      init(new URLSearchParams(params), target, logs);
  }
}

/** This entry-point may be called either directly from a same-origin host,
 * or by the window.onload handler
 */
function init(params, target, logs_src) {
  // Chrome treats local files specially: they all have target &apos;null&apos; for purposes of postMessage
  global_target = (window.chrome != null &amp;&amp; target == &quot;file://&quot;) ? null : target;
  global_messages = [];
  global_log_counts = {};

  let acc = [];
  let log = &quot;(default)&quot;;
  const lines = logs_src.split(/\r?\n/);
  for (const line of lines) {
    const match = line.match(/^==&gt; (.*) &lt;==$/);
    if (match) {
      global_messages = global_messages.concat(parse_log(log, acc));
      log = logname_from_filepath(match[1]);
      acc = [];
    } else {
      acc.push(line);
      continue;
    }
  }
  global_messages = global_messages.concat(parse_log(log, acc));
  reconcile_log_dates(global_messages);
  global_log_counts = tally_logs(global_messages);
  for (let i=0; i&lt;global_messages.length; i++) global_messages[i].gindex=i;

  render_page();
  render_controls();
  document.getElementById(
      &quot;loading&quot;
  ).innerText = `Loading ${global_messages.length} messages...`;
  write_controls(params);
  control_handler({type: &apos;init&apos;});

  // If resizes causes messages to wrap, we&apos;ll need to re-render them:
  window.onresize = (event) =&gt; control_handler(event);
  // If user presses Escape, hide all active pops:
  document.onkeydown = (event) =&gt; hide_popups_handler(event);
  // We synthesize background colors lazily with this function:
  document.addEventListener(&quot;scroll&quot;, () =&gt; render_missing_backgrounds());
}

// ===================================================================
// ===================================================================
// ===================================================================
// ===================================================================
// EVENT HANDLERS
// ===================================================================
// ===================================================================
// ===================================================================
// ===================================================================


/** Called by a click on the Load button. Job is to ingest the log,
 * update controls, and re-render.
 */
function load_button_handler(event) {
  const [file] = document.querySelector(&quot;input[type=file]&quot;).files;
  if (!file) return;
  const reader = new FileReader();
  reader.addEventListener(
    &quot;load&quot;,
    (event) =&gt; {
      const log = logname_from_filepath(file.name);
      const lines = reader.result.split(/\r?\n/);
      global_messages = global_messages.concat(parse_log(log, lines));
      reconcile_log_dates(global_messages);
      global_log_counts = tally_logs(global_messages);
      for (let i=0; i&lt;global_messages.length; i++) global_messages[i].gindex=i;
      render_controls();
      const params = new URLSearchParams(window.location.search);
      write_controls(params);
      control_handler(event);
    },
    false
  );
  reader.readAsText(file);
}

/** This is called on changes to controls. Its main response is to recompute
 * the message-list. This method debounces the recoputation.
 * (1) If the user makes a change in a textarea control e.g. the filter or the text,
 *     then we will recompute the message-list. Also we&apos;ll adjusts the height
 *     of the textarea to fit everything.
 * (2) If the user clicks a log button or dropdown, or alters the time,
 *     then again we&apos;ll recompute the message-list.
 * (3) If the user resizes the window, then surprisingly we might need a debounced
 *     recompute of the message-list. In particular if the resize causes
 *     messages to wrap differently (detected by the new height of the bottom
 *     message to be different from what it was before) then all backgrounds and
 *     lines in the display must be thrown out and recomputed.
 * (4) If the user clicks the load button, then after the load we do a debounced
 *     recompute of the message-list
 * (5) On window.load, after parsing the addendum, we do a debounced recompute
 *     of the message-list
 */
function control_handler(event) {
  // Commonly, we&apos;ll use a timeout that&apos;s snappy for small message-lists
  // that can be recomputed quickly, and slower for larger lists.
  const displayed_message_length =
    document.getElementById(&quot;messages&quot;).childElementCount;
  const message_burden =
    displayed_message_length == 0
      ? global_messages.length
      : displayed_message_length;
  let timeout = message_burden &gt; 10000 ? 1000 : message_burden &gt; 3000 ? 250 : 50;
  let update_url = true;

  if (event.type == &quot;init&quot; || event.type == &quot;load&quot;) {
    // upon init and load, we&apos;ll only have a short timeout to allow the screen to render;
    // we want the messages to be recomputed as soon as rendering is done.
    timeout = 1;
  } else if (event.type == &quot;resize&quot;) {
    // upon window-resize, if the wrapping (hence, vertical height) of the message-list
    // hasn&apos;t changed then there&apos;s no need to recompute anything.
    const lastChild = document.getElementById(&quot;messages&quot;).lastChild;
    const height =
      lastChild == null ? 0 : lastChild.offsetTop + lastChild.offsetHeight;
    if (height == global_resize_expected_height) return;
    // If we do need to recompute in response to window-resize, we&apos;ll do so with
    // a fairly high timeout.
    timeout = 250;
    update_url = false;
  } else if (
    event.type == &quot;change&quot; &amp;&amp;
    (event.target.id == &quot;select_start&quot; || event.target.id == &quot;select_end&quot;)
  ) {
    // user clicked on a start/end dropdown. That has already had the effect of updating
    // the start/end inputs, but bypassed their normal firing of events, which is why
    // we handle it.
    // There&apos;s no need for debouncing here.
    timeout = 1;
  } else if (event.type == &quot;change&quot; &amp;&amp; event.target.id == &quot;time_menu&quot;) {
    // user clicked on a time popup. Again, no need for debouncing.
    timeout = 1;
  } else if (event.type == &quot;input&quot; &amp;&amp; event.target.id == &quot;input_start&quot;) {
    // user typed in the time boxes. Uses normal debounce. Also, deselect the &quot;select&quot; dropdown
    document.getElementById(&quot;select_start&quot;).selectedIndex = 0;
  } else if (event.type == &quot;input&quot; &amp;&amp; event.target.id == &quot;input_end&quot;) {
    // user typed in the time boxes. Uses normal debounce. Also, deselect the &quot;select&quot; dropdown
    document.getElementById(&quot;select_end&quot;).selectedIndex = 0;
  } else if (event.type == &quot;input&quot; &amp;&amp; event.target.tagName == &quot;TEXTAREA&quot;) {
    // User typed in a textbox.
    // We&apos;ll immediately adjust the size of the textbox to fit whatever&apos;s there,
    // and update the autocomplete, and kick off a recompute using the normal debounce.
    event.target.style.height = &quot;&quot;;
    event.target.style.height = event.target.scrollHeight + &quot;px&quot;;
  } else if (
    event.type == &quot;change&quot; &amp;&amp;
    (event.target.id.startsWith(&quot;logcheck&quot;) ||
      event.target.id.startsWith(&quot;logalign&quot;))
  ) {
    // clicked on a checkbox or an alignment button for logs.
    // We&apos;ll use standard debounce.
  } else {
    throw new Error(`control_handler ${event.target.id || &quot;?&quot;}.${event.type}`);
  }

  // update URL
  const params = read_controls();
  if (update_url) {
    window.top.postMessage(params.toString(), global_target);
  }

  clearTimeout(global_debounce_timeout);
  global_debounce_timeout = setTimeout(() =&gt; {
    // figure out the controls
    const filter = params.has(&quot;filter&quot;) ? params.get(&quot;filter&quot;) : defaults.filter;
    const start = params.has(&quot;start&quot;) ? params.get(&quot;start&quot;) : defaults.start;
    const end = params.has(&quot;end&quot;) ? params.get(&quot;end&quot;) : defaults.end;
    const text = params.has(&quot;text&quot;) ? params.get(&quot;text&quot;) : defaults.text;
    const id = params.has(&quot;id&quot;) ? params.get(&quot;id&quot;) : defaults.id;
    const color = params.has(&quot;color&quot;) ? params.get(&quot;color&quot;) : defaults.color;
    let log_filter={}, log_align={};
    for (const [log, count] of Object.entries(global_log_counts)) {
      const key = `log_${log}`;
      if (params.has(key)) {
        log_filter[log] = !params.get(key).startsWith(&quot;hide_&quot;);
        log_align[log] = params.get(key).replace(/^hide_/, &quot;&quot;);
      } else {
        log_filter[log] = count &lt; defaults.threshold_for_visible;
        log_align[log] = (log == &quot;server&quot; || log.endsWith(&quot;:server&quot;)) ? defaults.align_for_server_log : defaults.align_for_other_logs;
      }
    }
    let start_time = null, end_time = null, time_exn = null;
    if (start.charAt(0) == &quot;-&quot;) {
      try {
        end_time = parseTimeControl(end, global_messages);
      } catch (e) {
        time_exn = time_exn || e;
      }
      try {
        start_time = parseTimeControl(start, global_messages, end_time);
      } catch (e) {
        time_exn = time_exn || e;
      }
    } else {
      try {
        start_time = parseTimeControl(start, global_messages);
      } catch (e) {
        time_exn = time_exn || e;
      }
      try {
        end_time = parseTimeControl(end, global_messages, start_time);
      } catch (e) {
        time_exn = time_exn || e;
      }
    }
    // make functions out of them
    const text_fn = make_fn(text);
    const id_fn = make_fn(id);
    const color_fn = make_fn(color);
    const filter_fn = make_fn(filter || &quot;true&quot;);
    const filter2_fn = (m) =&gt; log_filter[m.log] &amp;&amp; filter_fn(m);
    const align_fn = (m) =&gt; log_align[m.log];
    // render into html
    const t0 = performance.now();
    const { messages, filter_exn } = filter_and_sort_messages(
      global_messages,
      filter2_fn,
      start_time,
      end_time
    );
    const t1 = performance.now();
    const { text_exn, id_exn, color_exn } = render_messages(
      messages,
      text_fn,
      id_fn,
      color_fn,
      align_fn
    );
    const t2 = performance.now();
    render_error(document.getElementById(&quot;error_filter&quot;), filter_exn);
    render_error(document.getElementById(&quot;error_time&quot;), time_exn);
    render_error(document.getElementById(&quot;error_text&quot;), text_exn);
    render_error(document.getElementById(&quot;error_id&quot;), id_exn);
    render_error(document.getElementById(&quot;error_color&quot;), color_exn);
    const t3 = performance.now();
    render_missing_backgrounds();
    const t4 = performance.now();
    // update or hide the persistent details popup
    const mindex = messages.findIndex(
      (m) =&gt; m.gindex == global_popup_message_index
    );
    if (mindex == -1 &amp;&amp; messages.length &gt; 0) render_popup(null);
    else render_popup(document.getElementById(&quot;messages&quot;).children[mindex]);
    // set some global values
    const t5 = performance.now();
    global_current_dictionary = build_dictionary(messages);
    const t6 = performance.now();
    const lastChild = document.getElementById(&quot;messages&quot;).lastChild;
    global_resize_expected_height =
      lastChild == null ? 0 : lastChild.offsetTop + lastChild.offsetHeight;
    // render perf
    const perfElement = document.getElementById(&quot;perf&quot;);
    let perf = ``;
    perf += `filter_msgs [${(t1-t0).toFixed()}ms]\n`;
    perf += `render_msgs [${(t2-t1).toFixed()}ms]\n`;
    perf += `autocomplet [${(t6-t4).toFixed()}ms]`;
    perfElement.innerText = perf;
    perfElement.style.display = (t5 - t0 &gt; 500) ? &apos;block&apos; : &apos;none&apos;;
  }, timeout);
}

/** called by a messagetext&apos;s onclick handler, for
 * when the user clicks on a message to toggle its details popup.
 */
function message_handler(event, messageDiv, gindex) {
  event.stopPropagation();
  document.getElementById(&quot;menu&quot;).style.display = &quot;none&quot;;
  if (global_popup_message_index == gindex &amp;&amp; document.getElementById(&apos;popup&apos;).style.display == &apos;block&apos;) {
    global_popup_message_index = -1;
    render_popup(null);
  } else {
    global_popup_message_index = gindex;
    render_popup(messageDiv);
  }
}

/** Called by messagetime&apos;s onclick handler, for when
 * the user clicks on a time to show a popup which then
 * is able to set the start/end times.
 */
function time_handler(event, time) {
  event.stopPropagation();
  render_popup(null);
  const menu = document.getElementById(&quot;menu&quot;);
  menu.style.display = &quot;block&quot;;
  let html = `&lt;select id=&apos;time_menu&apos; multiple size=2&gt;`;
  html += `&lt;option value=&apos;start&apos;&gt;set start&lt;/option&gt;`;
  html += `&lt;option value=&apos;end&apos;&gt;set end&lt;/option&gt;`;
  html += `&lt;/select&gt;`;
  menu.innerHTML = html;
  const {x, y} = boundPopup(menu, event.target, &apos;left&apos;);
  menu.style.top = `${y}px`;
  menu.style.left = `${x}px`;
  const select = menu.getElementsByTagName(&quot;select&quot;)[0];
  select.addEventListener(&quot;change&quot;, (event) =&gt; {
    menu.style.display = &quot;none&quot;;
    const value = select.options[select.selectedIndex].value;
    const input =
      value == &quot;end&quot;
        ? document.getElementById(&quot;input_end&quot;)
        : document.getElementById(&quot;input_start&quot;);
    input.value = formatTimeControl(time, global_messages);
    // we&apos;ll also reset the input-time-control dropdown back to &quot;(select)&quot;
    document.getElementById(value == &quot;end&quot; ? &quot;select_end&quot; : &quot;select_start&quot;).selectedIndex = 0;
    control_handler(event);
  });
}

/** Called by keyup, click and focus events on a textarea.
 * Its job is to show or hide the autocomplete popup as appropriate.
 * Keyup covers typing and cursoring.
 * Click covers when you click on it to focus, and also when you click to reposition the caret.
 * Focus covers when you click on it to focus, and also when you tab to focus.
 * We often end up getting both Click and Focus e.g. when we gain focus from elsewhere. No matter.
 */
function autocomplete_handler(event) {
  const menuElement = document.getElementById(&quot;menu&quot;);

  if (event.type == &quot;keyup&quot; &amp;&amp; event.key == &quot;Escape&quot;) {
    // this handler is invoked to show autocomplete in response to keystrokes,
    // but if the keystroke was an escape then we won&apos;t!
    return;
  }
  // This is the entire text leading up to the caret:
  let text = event.target.value.substring(0, event.target.selectionStart);
  // We won&apos;t be fancy about nesting, but we will track
  // whether there&apos;s an unbalanced number of string quote delimeters
  if (
    text.split(&apos;&quot;&apos;).length % 2 == 0 ||
    text.split(&quot;&apos;&quot;).length % 2 == 0 ||
    text.split(&quot;`&quot;).length % 2 == 0
  )
    text = &quot;&quot;;
  // Replace all [...] with .ELEMENT and replace all ?. with .
  text = text.replace(/\[[^\]]*\]/g, &quot;.ELEMENT&quot;);
  text = text.replace(/\?\./g, &quot;.&quot;);
  // Find the longest identifier+dot string leading to the caret
  const match = text.match(
    /(([a-zA-Z_][a-zA-Z0-9_]*\.)*[a-zA-Z_][a-zA-Z0-9_]*\.?)$/
  );
  text = match ? match[1] : &quot;&quot;;
  const identifiers = text.split(&quot;.&quot;);
  // Walk the identifier chain to find autocomplete up to the second-last identifier in the chain.
  let current = global_current_dictionary;
  for (let i = 0; current != null &amp;&amp; i &lt; identifiers.length - 1; i++) {
    current = current[identifiers[i]]?.nested;
  }
  if (current == null) {
    menuElement.style.display = &quot;none&quot;;
    return;
  }
  // The last identifier in the chain is the one that the caret is currently on,
  // e.g. for &quot;foo.|&quot; the last identifier will be the empty string, and for &quot;foo|&quot; it will be &quot;foo&quot;.
  // We&apos;ll use it as a filter to only show some options.
  let filter = identifiers.pop();
  let html = `&lt;table id=&apos;autocomplete&apos;&gt;`;
  for (const [k, v] of Object.entries(current)) {
    if (k.startsWith(filter)) {
      html += `&lt;tr&gt;&lt;td class=&quot;autocomplete_name&quot;&gt;${
        k == &quot;ELEMENT&quot; ? &quot;[]&quot; : esc(k)
      }&lt;/td&gt;&lt;td class=&quot;autocomplete_hint&quot;&gt;${esc(v.hint)}&lt;/td&gt;&lt;/tr&gt;`;
    }
  }
  html += `&lt;/table&gt;`;
  // And render it!
  menuElement.innerHTML = html;
  menuElement.style.display = &quot;block&quot;;
  const { x, y } = boundPopup(menuElement, event.target, &quot;left&quot;);
  menuElement.style.top = `${y}px`;
  menuElement.style.left = `${x + event.target.offsetWidth}px`;
}

/** Called by the &quot;body&quot; onclick handler, for when the
 * user clicks in the background to dismiss any popups.
 * Also called by the document keydown event handler, for
 * when the user presses escape to dismiss popups.
 */
function hide_popups_handler(event) {
  let dismiss_menu = false;
  let dismiss_popup = false;
  if (event.type == &quot;keydown&quot; &amp;&amp; event.key == &quot;Escape&quot;) {
    // will dismiss them both
    dismiss_menu = true;
    dismiss_popup = true;
  } else if (event.type == &quot;click&quot;) {
    // the time menu will be dismissed by any click not on it
    // the autocomplete popup will be dismissed by any click not on it and not on a textarea
    const menu = document.getElementById(&quot;menu&quot;);
    if (event.target.offsetParent != menu) dismiss_menu = true;
    if (
      menu.firstChild?.id != &quot;time_menu&quot; &amp;&amp;
      event.target.tagName == &quot;TEXTAREA&quot;
    ) {
      dismiss_menu = false;
    }
    // the details-popup is more sticky: clicking in the #left panel won&apos;t dismiss it
    let parent = event.target;
    while (parent != null &amp;&amp; parent.id != &quot;left&quot;) parent = parent.offsetParent;
    dismiss_popup = parent == null;
  }
  if (dismiss_menu) menu.style.display = &quot;none&quot;;
  if (dismiss_popup) {global_popup_message_index = -1; render_popup(null);}
}

// ===================================================================
// ===================================================================
// ===================================================================
// ===================================================================
// RENDERING FUNCTIONS INTO THE HTML
// ===================================================================
// ===================================================================
// ===================================================================
// ===================================================================
  
/** Seaoflogs will be set up with an empty body, because it initializes its controls here. */
function render_page() {
  const body = document.getElementsByTagName(&quot;body&quot;)[0];
  body.onclick = hide_popups_handler;
  body.innerHTML = `
  &lt;div id=&quot;left&quot;&gt;
    &lt;div id=&quot;title&quot;&gt;
      &lt;table&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;b&gt;Sea of logs&lt;/b&gt;&lt;/td&gt;
          &lt;td&gt;
            &lt;label for=&quot;load&quot; id=&quot;loadbutton&quot;&gt;Load...&lt;/label&gt;
            &lt;input type=&quot;file&quot; id=&quot;load&quot; onchange=&apos;load_button_handler(event)&apos; /&gt;
          &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;
      &lt;hr /&gt;
    &lt;/div&gt;
    &lt;div id=&quot;logs&quot;&gt;
      &lt;table id=&quot;logs_table&quot;&gt;&lt;/table&gt;
      &lt;hr /&gt;
    &lt;/div&gt;
    &lt;div id=&quot;time&quot;&gt;
      &lt;table&gt;
        &lt;tr&gt;
          &lt;td&gt;Start&lt;/td&gt;
          &lt;td&gt;
            &lt;input id=&quot;input_start&quot; style=&quot;width: 6em;&quot; onfocus=&quot;this.select()&quot; oninput=&apos;control_handler(event)&apos;
              type=&quot;text&quot;&gt;
            &lt;select id=&quot;select_start&quot; style=&quot;width: 2.5ex;&quot;
              onchange=&quot;if (this.selectedIndex != 0) {document.getElementById(&apos;input_start&apos;).value=this.options[this.selectedIndex].value;control_handler(event);}&quot;&gt;&lt;/select&gt;
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;End&lt;/td&gt;
          &lt;td&gt;
            &lt;input id=&quot;input_end&quot; style=&quot;width: 6em;&quot; onfocus=&quot;this.select()&quot; oninput=&apos;control_handler(event)&apos;
              type=&quot;text&quot;&gt;
            &lt;select id=&quot;select_end&quot; style=&quot;width: 2.5ex;&quot;
              onchange=&quot;if (this.selectedIndex != 0) {document.getElementById(&apos;input_end&apos;).value=this.options[this.selectedIndex].value;control_handler(event);}&quot;&gt;&lt;/select&gt;
          &lt;/td&gt;
      &lt;/table&gt;
      &lt;div class=&quot;error&quot; id=&quot;error_time&quot; style=&quot;display: none;&quot;&gt;&lt;/div&gt;
      &lt;hr /&gt;
    &lt;/div&gt;
    &lt;div id=&quot;filter&quot;&gt;
      Filter&lt;br /&gt;
      &lt;textarea id=&quot;input_filter&quot; wrap=&apos;soft&apos; type=&apos;text&apos; oninput=&apos;control_handler(event)&apos;
        onclick=&apos;autocomplete_handler(event)&apos; onkeyup=&apos;autocomplete_handler(event)&apos;
        onfocus=&apos;autocomplete_handler(event)&apos;&gt;&lt;/textarea&gt;
      &lt;div class=&quot;error&quot; id=&quot;error_filter&quot; style=&quot;display: none;&quot;&gt;&lt;/div&gt;
      &lt;hr /&gt;
    &lt;/div&gt;
    &lt;div id=&quot;text&quot;&gt;
      Text&lt;br /&gt;
      &lt;textarea id=&quot;input_text&quot; wrap=&quot;soft&quot; type=&apos;text&apos; oninput=&apos;control_handler(event)&apos;
        onclick=&apos;autocomplete_handler(event)&apos; onkeyup=&apos;autocomplete_handler(event)&apos;
        onfocus=&apos;autocomplete_handler(event)&apos;&gt;title&lt;/textarea&gt;
      &lt;div class=&quot;error&quot; id=&quot;error_text&quot; style=&quot;display: none;&quot;&gt;&lt;/div&gt;
      &lt;hr /&gt;
    &lt;/div&gt;
    &lt;div id=&quot;color&quot;&gt;
      Color&lt;br /&gt;
      &lt;textarea id=&quot;input_color&quot; wrap=&quot;soft&quot; type=&apos;text&apos; oninput=&apos;control_handler(event)&apos;
        onclick=&apos;autocomplete_handler(event)&apos; onkeyup=&apos;autocomplete_handler(event)&apos;
        onfocus=&apos;autocomplete_handler(event)&apos;&gt;title&lt;/textarea&gt;
      &lt;div class=&quot;error&quot; id=&quot;error_color&quot; style=&quot;display: none;&quot;&gt;&lt;/div&gt;
      &lt;hr /&gt;
    &lt;/div&gt;
    &lt;div id=&quot;id&quot;&gt;
      Id&lt;br /&gt;
      &lt;textarea id=&quot;input_id&quot; wrap=&quot;soft&quot; type=&apos;text&apos; oninput=&apos;control_handler(event)&apos;
        onclick=&apos;autocomplete_handler(event)&apos; onkeyup=&apos;autocomplete_handler(event)&apos;
        onfocus=&apos;autocomplete_handler(event)&apos;&gt;id&lt;/textarea&gt;
      &lt;div class=&quot;error&quot; id=&quot;error_id&quot; style=&quot;display: none;&quot;&gt;&lt;/div&gt;
      &lt;hr /&gt;
    &lt;/div&gt;
    &lt;div id=&quot;details&quot;&gt;
      Details&lt;br /&gt;
      &lt;textarea id=&quot;input_details&quot; wrap=&quot;soft&quot; type=&apos;text&apos; oninput=&apos;control_handler(event)&apos;
        onclick=&apos;autocomplete_handler(event)&apos; onkeyup=&apos;autocomplete_handler(event)&apos;
        onfocus=&apos;autocomplete_handler(event)&apos;&gt;message&lt;/textarea&gt;
      &lt;div class=&quot;error&quot; id=&quot;error_details&quot; style=&quot;display: none;&quot;&gt;&lt;/div&gt;
      &lt;hr /&gt;
    &lt;/div&gt;
    &lt;pre id=&quot;perf&quot;&gt;&lt;/pre&gt;
  &lt;/div&gt;
  &lt;div id=&quot;right&quot;&gt;
    &lt;div id=&quot;backgrounds&quot;&gt;
    &lt;/div&gt;
    &lt;div id=&quot;connectors&quot;&gt;
      &lt;svg id=&quot;svg&quot; width=&quot;100%&quot; height=&quot;100&quot; viewbox=&quot;0 0 400 100&quot; preserveAspectRatio=&quot;none&quot;&gt;&lt;/svg&gt;
    &lt;/div&gt;
    &lt;div id=&quot;messages&quot;&gt;
      &lt;pre id=&quot;loading&quot;&gt;Loading...&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div id=&quot;popup&quot;&gt;&lt;/div&gt;
  &lt;div id=&quot;menu&quot;&gt;&lt;/div&gt;`;
}

/** Figures out a good {x,y} for the popup to display related to the element.
 * If align is &apos;right&apos; then it will align to the right of the element,
 * otherwise to the left.
 */
function boundPopup(popup, element, align) {
  const rPopup = popup.getBoundingClientRect();
  const rElement = element.getBoundingClientRect(); // relative to screen
  const rWindow = { right: window.innerWidth, bottom: window.innerHeight };
  // popup will be offset to the left of right-column, or offset to right of left-column
  // but clipped within bounds
  let x = align == &quot;right&quot; ? rElement.right - rPopup.width : rElement.left;
  if (x + rPopup.width &gt; rWindow.right) x = rWindow.right - rPopup.width;
  if (x &lt; 0) x = 0;
  // popup will go underneath element if it fits, else above if it fits, else underneath
  let y =
    rElement.bottom + rPopup.height &lt; rWindow.bottom
      ? rElement.bottom
      : rElement.top - rPopup.height &gt;= 0
      ? rElement.top - rPopup.height
      : rElement.bottom;
  return { x, y };
}

/** Either shows or hides &apos;element&apos; according to whether to show the exception
 */
function render_error(element, exn) {
  element.innerText = String(exn);
  element.style.display = exn == null ? &quot;none&quot; : &quot;block&quot;;
}

/** Renders this list of messages into html elements #messages, #svg, #backgrounds.
 * Depends on the input messages having additional &apos;gindex&apos; and &apos;filter&apos; properties.
 * Returns {text_exn, id_exn, color_exn} for any errors encountered
 */
function render_messages(messages, text_fn, id_fn, color_fn, align_fn) {
  let text_exn = null;
  let id_exn = null;
  let color_exn = null;

  // This is where we&apos;ll render to
  const messagesElement = document.getElementById(&quot;messages&quot;);
  const svgElement = document.getElementById(&quot;svg&quot;);
  const backgroundsElement = document.getElementById(&quot;backgrounds&quot;);

  // If anything does throw, these are the values we&apos;ll use
  const color_error = &quot;#E00000&quot;;
  const text_error = `&lt;span class=&apos;error&apos;&gt;error&lt;/span&gt;`;

  // Some derived values for layout
  let gaps = []; // gap[i] is the extra padding above message i, where 0=no padding and 1=1 line of padding
  let pos = []; // pos[i] = {left, top, width, height, cx, cy} for message i
  let idmap = {}; // a map {id -&gt; [i1, i2]}, but only listing ones that pass the filter

  // Here we compute &apos;gaps&apos; derived values, the extra padding above messages.
  // The idea is that messages-with-time go first in the list. If at least three messages
  // have times, then we&apos;ll set up the &apos;gap&apos; array to scale their positions.
  let time_count = messages.findIndex((m) =&gt; m.time == null);
  time_count = time_count == -1 ? messages.length : time_count;
  if (time_count &gt;= 3) {
    const earliest_time = messages[0].time;
    const latest_time = messages[time_count - 1].time;
    // Imagine N=time_count messages spread over a vertical axis according to their
    // timestamp, where the vertical axis is 4N tall. This implies the natural &quot;y&quot;
    // of each element, and hence the natural separation between two elements.
    // We will cap the separation into the range [1..5], and define gap=separation-1.
    const yrange = time_count * 4; // 4N
    const timerange = latest_time.getTime() - earliest_time.getTime();
    gaps[0] = 0;
    for (let i = 1; i &lt; time_count; i++) {
      const prev_natural_y =
        ((messages[i - 1].time.getTime() - earliest_time.getTime()) /
          timerange) *
        yrange;
      const natural_y =
        ((messages[i].time.getTime() - earliest_time.getTime()) / timerange) *
        yrange;
      let separation = natural_y - prev_natural_y;
      separation = Math.max(Math.min(separation, 5), 1);
      gaps[i] = separation - 1;
    }
  }
  // Let&apos;s place a gap of 4 between messages-with-time and those without,
  // and then all messages-without-time will be adjacent to each other.
  for (let i = time_count; i &lt; messages.length; i++) {
    gaps[i] = i == time_count &amp;&amp; i != 0 ? 4 : 0;
  }
  // If every single element was spaced out, we might as well compress them.
  const mingap = Math.min(...gaps.slice(1, time_count - 1));
  for (let i = 1; i &lt; time_count; i++) {
    gaps[i] -= mingap;
  }

  // Render phase 1: this inserts html into messagesElement, and computes pos[] and idmap[]
  let html = &quot;&quot;;
  for (let i = 0; i &lt; messages.length; i++) {
    const m = messages[i];
    const align = align_fn(m);
    let text;
    try {
      text = esc(text_fn(m));
    } catch (e) {
      text_exn = text_exn || e;
      text = text_error;
    }
    let color;
    try {
      color = color_fn(m);
      if (typeof color === &quot;string&quot; &amp;&amp; color.match(/^#[0-9a-fA-F]..(...)?$/)) {
          // it&apos;s a color string of the form &quot;#abc&quot; or &quot;#abcdef&quot;
      } else {
          color = hsl((hash(String(color)) % 12) / 12.0, 0.5, 0.9);
      }
    } catch (e) {
      color_exn = color_exn || e;
      color = color_error;
    }
    let ids;
    try {
      ids = id_fn(m);
      if (Array.isArray(ids)) {
        ids = Array.from(new Set(ids.filter(x =&gt; x != null).map(x =&gt; String(x))).values());
      } else if (ids != null) {
        ids = [String(ids)];
      } else {
        ids = [];
      }
    } catch (e) {
      id_exn = id_exn || e;
      ids = [];
      color = color_error;
    }
    // derived quantities pos[] and idmap[]
    let jiggle = (hash(text) % 6) - 3;
    pos[i] = { cx: align == &quot;right&quot; ? 370 + jiggle : align == &quot;left&quot; ? 30 + jiggle : 200 + jiggle};
    for (const id of ids) {
      if (idmap[id] == null) idmap[id] = [];
      idmap[id].push(i);
    }
    // produce the html for this message
    let time = &quot;&quot;;
    if (m.time != null) {
      time = formatCompactTime(m.time);
      time = `&lt;span class=&apos;messagetime&apos;&gt;${
        align == &quot;right&quot; ? &quot;&amp;nbsp;&quot; : &quot;&quot;
      }${time}${align == &quot;right&quot; ? &quot;&quot; : &quot;&amp;nbsp;&quot;}&lt;/span&gt;`;
    }
    let time_right = align == &quot;right&quot; ? time : &quot;&quot;;
    let time_left = align == &quot;right&quot; ? &quot;&quot; : time;
    const gap = gaps[i] == 0 ? &quot;&quot; : `margin-top: ${gaps[i] * 3}ex;`;
    const s = `&lt;div class=&quot;message&quot; style=&apos;text-align: ${align}; ${gap}&apos; data-color=&apos;${color}&apos;&gt;&lt;span class=&quot;messageall&quot;&gt;${time_left}&lt;span class=&quot;messagetext&quot;&gt;${text}&lt;/span&gt;${time_right}&lt;/span&gt;&lt;/div&gt;`;
    html += s;
  }
  messagesElement.innerHTML = html;

  // Render phase 2: uses the message elements that have been created to obtain
  // layout information, set up handlers on them, and completes pos[]
  for (let i = 0; i &lt; messages.length; i++) {
    const element = messagesElement.children[i];
    const message = messages[i];
    const gindex = message.gindex;
    const textspan = element.getElementsByClassName(&quot;messagetext&quot;)[0]; // should definitely be there
    const timespan = element.getElementsByClassName(&quot;messagetime&quot;)[0]; // may not be there
    textspan.addEventListener(&quot;click&quot;, (event) =&gt;
      message_handler(event, element, gindex)
    );
    timespan?.addEventListener(&quot;click&quot;, (event) =&gt;
      time_handler(event, message.time)
    );
    timespan?.addEventListener(&quot;contextmenu&quot;, (event) =&gt; {
      event.preventDefault();
      time_handler(event, message.time);
    });
    pos[i] = {
      left: element.offsetLeft,
      top: element.offsetTop,
      width: element.offsetWidth,
      height: element.offsetHeight,
      cx: pos[i].cx,
      cy: element.offsetTop + element.offsetHeight / 2,
    };
  }

  // Render phase 3: update svg, which contains the lines.
  // The svg element will have &quot;width=100% height=&lt;natural_height&gt;&quot; to fill entire space.
  // The viewbox will have &quot;width=400 height=&lt;natural_height&gt;&quot;
  // so that coordinates of elements will be normalized to an X range [0..400]
  // and a Y range identical to the pixel positions of the elements
  const lastChild = messagesElement.lastChild;
  const height =
    lastChild == null ? 0 : lastChild.offsetTop + lastChild.offsetHeight;
  svgElement.setAttribute(&quot;height&quot;, height);
  svgElement.setAttribute(&quot;viewBox&quot;, `0 0 400 ${height}`);
  // Now assemble the content of the svg, i.e. the id lines
  let svg = &quot;&quot;;
  for (const [id, indexes] of Object.entries(idmap)) {
    if (indexes.length &lt;= 1) continue;
    const color = hsl((hash(id) % 12) / 12.0, 0.9, 0.4);
    for (let vi = 0; vi &lt; indexes.length - 1; vi++) {
      const m1 = indexes[vi];
      const m2 = indexes[vi + 1];
      svg += `&lt;line x1=&apos;${pos[m1].cx}&apos; y1=&apos;${pos[m1].cy}&apos; x2=&apos;${pos[m2].cx}&apos; y2=&apos;${pos[m2].cy}&apos; stroke=&apos;${color}&apos;/&gt;`;
    }
    for (let vi = 0; vi &lt; indexes.length; vi++) {
      const m1 = indexes[vi];
      svg += `&lt;ellipse cx=&apos;${pos[m1].cx}&apos; cy=&apos;${pos[m1].cy}&apos; rx=&apos;1&apos; ry=&apos;2&apos; fill=&apos;${color}&apos;/&gt;`;
    }
  }
  svgElement.innerHTML = svg;

  // As for backgrounds, they&apos;re not done here; they&apos;re all provided lazily
  // by render_missing_backgrounds. That&apos;s because assembling a load of html
  // is the bottleneck, and we don&apos;t want to do more of it than necessary
  backgroundsElement.innerHTML = &quot;&quot;;

  return { text_exn, id_exn, color_exn };
}

/** Generate any needed background divs that (lazily) were deferred
 * until they scrolled into view.
 */
function render_missing_backgrounds() {
  const container = document.getElementById(&quot;messages&quot;);
  // let&apos;s bisect to find the first child visible in the viewport
  // i.e. the first element whose bottom is &gt; 0
  let ifirst = 0;
  let ilast = container.childElementCount;
  while (ilast - ifirst &gt; 1) {
    const i = Math.floor((ifirst + ilast) / 2);
    const r = container.children[i].getBoundingClientRect();
    if (r.bottom &gt; 0) ilast = i;
    else if (r.bottom &lt;= 0) ifirst = i;
  }
  for (let i = ifirst; i &lt; container.childElementCount; i++) {
    const element = container.children[i];
    const r = element.getBoundingClientRect();
    if (r.top &gt; container.offsetHeight) return;
    const color = element.getAttribute(&quot;data-color&quot;);
    if (color == null) continue;
    element.removeAttribute(&quot;data-color&quot;, null);
    const span = element.children[0];
    const html = `&lt;div class=&apos;background&apos; style=&apos;position:relative; width:100%; height:0; margin:0; top:${element.offsetTop}px; text-align:${element.style.textAlign};&apos;&gt;&lt;span style=&apos;display:inline-block; width:${span.offsetWidth}px; height:${span.offsetHeight}px; background-color:${color};&apos;&gt;&lt;/span&gt;&lt;/div&gt;`;
    document
      .getElementById(&quot;backgrounds&quot;)
      .insertAdjacentHTML(&quot;beforeend&quot;, html);
  }
}

/** Either hides the details-popup (if given null) or renders
 * the message in &apos;global_messages[global_popup_message_index]&apos;
 * and attaches it to the messageDiv.
 * Note: this function reads the url query parameters for the code
 * to generate details; this query parameters were previously
 * written by control_handler.
 */
function render_popup(messageDiv) {
  // close the existing popup if necessary
  render_error(document.getElementById(&quot;error_details&quot;), null);
  document.getElementById(&quot;popup&quot;).style.display = &quot;none&quot;;
  if (messageDiv == null) return;
  // recompute the new popup value
  const params = new URLSearchParams(window.location.search);
  const details_fn = make_fn(params.get(&quot;details&quot;) || &quot;message&quot;);
  let details_exn = null;
  let details;
  try {
    details = details_fn(global_messages[global_popup_message_index]);
  } catch (e) {
    details = String(e);
    details_exn = e;
  }
  if (details == null) return;
  // render the popup
  if (details_exn == null) popup.innerText = details;
  else
    popup.innerHTML = `&lt;span class=&quot;error&quot;&gt;${esc(String(details_exn))}&lt;/span&gt;`;
  popup.style.display = &quot;block&quot;;
  let { x, y } = boundPopup(
    popup,
    messageDiv.getElementsByClassName(&quot;messagetext&quot;)[0],
    messageDiv.style.textAlign
  );
  const rMessagesDiv = document
    .getElementById(&quot;messages&quot;)
    .getBoundingClientRect();
  y -= rMessagesDiv.top;
  popup.style.left = `${x}px`;
  popup.style.top = `${y}px`;
  // Update error if necessary
  render_error(document.getElementById(&quot;error_details&quot;), details_exn);
}

/* Reads current controls. Returns a URLSearchParams with the following keys:
 * log_&lt;name&gt;_checked:bool, log_&lt;name&gt;_align:left|right|center, filter,start,end,text,id,color,details:string
 */
function read_controls() {
  let params = new URLSearchParams();
  const filter = document.getElementById(&quot;input_filter&quot;).value;
  const start = document.getElementById(&quot;input_start&quot;).value;
  const end = document.getElementById(&quot;input_end&quot;).value;
  const text = document.getElementById(&quot;input_text&quot;).value;
  const id = document.getElementById(&quot;input_id&quot;).value;
  const color = document.getElementById(&quot;input_color&quot;).value;
  const details = document.getElementById(&quot;input_details&quot;).value;
  if (filter != defaults.filter) params.set(&quot;filter&quot;, filter);
  if (start != defaults.start) params.set(&quot;start&quot;, start);
  if (end != defaults.end) params.set(&quot;end&quot;, end);
  if (text != defaults.text) params.set(&quot;text&quot;, text);
  if (id != defaults.id) params.set(&quot;id&quot;, id);
  if (color != defaults.color) params.set(&quot;color&quot;, color);
  if (details != defaults.details) params.set(&quot;details&quot;, details);
  for (const div of document.getElementsByClassName(&quot;log&quot;)) {
    const checkboxElement = div.getElementsByTagName(&quot;input&quot;)[0];
    const alignElement = div.getElementsByTagName(&quot;select&quot;)[0];
    const key = div.getAttribute(&quot;id&quot;); // e.g. &quot;log_client&quot;
    const value = checkboxElement.checked
      ? alignElement.value
      : &quot;hide_&quot; + alignElement.value; // e.g. &quot;left&quot; or &quot;hide_center&quot;
    const log = key.replace(/^log_/, &quot;&quot;);
    const def_checked = (global_log_counts[log] &lt; defaults.threshold_for_visible) ? &quot;&quot; : &quot;hide_&quot;;
    const def_align = (log == &quot;server&quot; || log.endsWith(&quot;:server&quot;)) ? defaults.align_for_server_log : defaults.align_for_other_logs;
    if (value == `${def_checked}${def_align}`) continue;
    params.set(key, value);
  }
  return params;
}

/** Writes a URLSearchParams into the UI controls
 */
function write_controls(params) {
  const write = (element, paramName, def) =&gt; {
    element.value = params.has(paramName) ? params.get(paramName) : def;
  };
  write(document.getElementById(&quot;input_filter&quot;), &quot;filter&quot;, defaults.filter);
  write(document.getElementById(&quot;input_start&quot;), &quot;start&quot;, defaults.start);
  write(document.getElementById(&quot;input_end&quot;), &quot;end&quot;, defaults.end);
  write(document.getElementById(&quot;input_text&quot;), &quot;text&quot;, defaults.text);
  write(document.getElementById(&quot;input_id&quot;), &quot;id&quot;, defaults.id);
  write(document.getElementById(&quot;input_color&quot;), &quot;color&quot;, defaults.color);
  write(document.getElementById(&quot;input_details&quot;), &quot;details&quot;, defaults.details);
  for (const div of document.getElementsByClassName(&quot;log&quot;)) {
    const checkboxElement = div.getElementsByTagName(&quot;input&quot;)[0];
    const alignElement = div.getElementsByTagName(&quot;select&quot;)[0];
    const key = div.getAttribute(&quot;id&quot;); // e.g. &quot;log_client&quot;
    const log = key.replace(/^log_/, &quot;&quot;);
    if (params.has(key)) {
      const value = params.get(key);
      checkboxElement.checked = !value.startsWith(&apos;hide_&apos;);
      alignElement.value = value.replace(/^hide_/, &quot;&quot;);
    } else {
      checkboxElement.checked = global_log_counts[log] &lt; defaults.threshold_for_visible;
      alignElement.value = (log == &quot;server&quot; || log.endsWith(&quot;:server&quot;)) ? defaults.align_for_server_log : defaults.align_for_other_logs;
    }
  }
}

/** Adds a new log dropdown. &apos;count&apos; is a number to show to its right.
 */
function append_log_control(log, count) {
  const name = log == null ? &quot;null&quot; : log;
  let html = &quot;&quot;;
  html += `&lt;td class=&quot;td_logleft&quot; &gt;`;
  html += `&lt;input id=&apos;logcheck_${name}&apos; onchange=&apos;control_handler(event)&apos; type=&apos;checkbox&apos; checked/&gt;`;
  html += `&lt;label for=&apos;logcheck_${name}&apos;&gt;${name}&lt;/label&gt; &lt;span class=&apos;logcount&apos;&gt;${count.toLocaleString()}&lt;/span&gt;&lt;/td&gt;`;
  html += `&lt;td class=&quot;td_logright&quot;&gt;&lt;select id=&apos;logalign_${name}&apos; onchange=&apos;control_handler(event)&apos;&gt;`;
  html += `&lt;option value=&quot;left&quot; selected&gt;L&lt;/option&gt;`;
  html += `&lt;option value=&quot;center&quot;&gt;C&lt;/option&gt;`;
  html += `&lt;option value=&quot;right&quot;&gt;R&lt;/option&gt;`;
  html += `&lt;/select&gt;&lt;/td&gt;`;
  const table = document.getElementById(&quot;logs_table&quot;);
  const tr = table.insertRow(table.rows.length);
  tr.className = &quot;log&quot;;
  tr.id = `log_${name}`;
  tr.innerHTML = html;
}

/**
 * Reads through the &apos;global_messages&apos; to see what logs-controls should be shown,
 * reads the UI to see what log-controls are already shown,
 * and adds to the UI any log-controls that are needed. Picks sensible &apos;align&apos; defaults
 * for them too.
 * Note: the log controls include the filter/alignment section and the time section.
 */
function render_controls() {
  // What log controls do we want to show?
  let logs = []; // ordered list of lognames
  let seen = new Set();
  for (const m of global_messages) {
    if (!seen.has(m.log)) {logs.push(m.log); seen.add(m.log);}
  }
  // Add in whichever ones aren&apos;t already shown
  for (const log of logs) {
    if (document.getElementById(`logcheck_${log}`) != null) continue;
    append_log_control(log, global_log_counts[log]);
  }
  document.getElementById(&apos;logs&apos;).style.display = logs.length &gt; 0 ? &apos;block&apos; : &apos;none&apos;;
  // What time controls do we want to show?
  let extremes = {};
  let earliest = null;
  let latest = null;
  for (const m of global_messages) {
    if (extremes[m.log] == null)
      extremes[m.log] = { earliest: null, latest: null };
    if (m.time == null) continue;
    if (earliest == null || m.time &lt; earliest) earliest = m.time;
    if (latest == null || m.time &gt; latest) latest = m.time;
    if (extremes[m.log].earliest == null || m.time &lt; extremes[m.log].earliest)
      extremes[m.log].earliest = m.time;
    if (extremes[m.log].latest == null || m.time &gt; extremes[m.log].latest)
      extremes[m.log].latest = m.time;
  }
  if (earliest == null) {
    document.getElementById(&quot;time&quot;).style.display = &quot;none&quot;;
    return;
  }
  document.getElementById(&quot;time&quot;).style.display = &quot;block&quot;;
  let s;
  s = formatTimeControl(earliest, global_messages);
  let html_start = `&lt;option&gt;(select)&lt;/option&gt;&lt;option&gt;&lt;/option&gt;&lt;option value=&apos;${s}&apos;&gt;${s}&lt;/option&gt;`;
  s = formatTimeControl(latest, global_messages);
  let html_end = `&lt;option&gt;(select)&lt;/option&gt;&lt;option&gt;&lt;/option&gt;&lt;option value=&apos;${s}&apos;&gt;${s}&lt;/option&gt;`;
  html_end += `&lt;option value=&apos;+5s&apos;&gt;+5s&lt;/option&gt;`;
  html_end += `&lt;option value=&apos;+10 minutes&apos;&gt;+10 minutes&lt;/option&gt;`;
  for (const log of logs) {
    if (extremes[log].earliest != null) {
      const s = formatTimeControl(extremes[log].earliest, global_messages);
      html_start += `&lt;option value=&apos;${s}&apos;&gt;${s} - ${log}&lt;/option&gt;`;
    }
    if (extremes[log].latest != null) {
      const s = formatTimeControl(extremes[log].latest, global_messages);
      html_end += `&lt;option value=&apos;${s}&apos;&gt;${s} - ${log}&lt;/option&gt;`;
    }
  }
  document.getElementById(&quot;select_start&quot;).innerHTML = html_start;
  document.getElementById(&quot;select_end&quot;).innerHTML = html_end;
}

// ===================================================================
// ===================================================================
// ===================================================================
// ===================================================================
// LOGIC
// ===================================================================
// ===================================================================
// ===================================================================
// ===================================================================

const defaults = {
  filter: &quot;&quot;,
  start: &quot;&quot;,
  end: &quot;&quot;,
  text: &quot;title || line&quot;,
  id: &quot;id&quot;,
  color: &quot;title&quot;,
  details: &quot;message&quot;,
  align_for_other_logs: &quot;left&quot;,
  align_for_server_log: &quot;right&quot;,
  threshold_for_visible: 2000,
};

/** Given a list of messages, returns {logname-&gt;count}.
 */
function tally_logs(messages) {
  let counts = {}; // map from logname to number of messages in that log
  for (const m of messages) {
    if (counts[m.log] == null) counts[m.log] = 0;
    counts[m.log] += 1;
  }
  return counts;
}

/** Returns a filtered+sorted list of messages to display.
 * source:message[]&apos; is a list of messages.
 * &apos;filter_fn:m-&gt;bool&apos; is a predicate on messages.
 * &apos;start:Date?&apos; and &apos;end:Date?&apos; are times.
 * Returns {messages: message[], filter_exn}
 * Each message returned actually has an additional property &apos;gindex&apos;,
 * for the index into the source list, and some have &apos;filter&apos; if
 * the filter function failed on them.
 */
function filter_and_sort_messages(source, filter_fn, start, end) {
  let filter_exn = null;

  // We&apos;ll stable-sort all messages by time, but putting unstamped messages at the end.
  // We also add a property &apos;gindex&apos; to the messages in our local &apos;messages&apos; array,
  // for the index into the global messages list, and an optional property
  // &apos;filter&apos; which has value null for everything that couldn&apos;t be filtered.
  let messages = [];
  for (let gindex=0; gindex&lt;global_messages.length; gindex++) {
    const m = global_messages[gindex];
    if (start != null &amp;&amp; (m.time == null || m.time &lt; start)) continue;
    if (end != null &amp;&amp; (m.time == null || m.time &gt; end)) continue;
    try {
      if (filter_fn(m)) messages.push(m);
    } catch (e) {
      filter_exn = filter_exn || e;
      messages.push(m); // still shown even with error
    }
  }
  messages.sort((a, b) =&gt;
    a.time == null &amp;&amp; b.time == null
      ? 0
      : b.time == null
      ? -1
      : a.time == null
      ? 1
      : a.time &lt; b.time
      ? -1
      : b.time &lt; a.time
      ? 1
      : 0
  );
  return { messages, filter_exn };
}

/** Attempts to parse the string as a date/time in a few common log idioms. Test cases at https://jsfiddle.net/z6g20nq1/1/ */
function tryParseLogTime(s) {
  const match = s.match(/(?&lt;y&gt;\d\d\d\d)-(?&lt;m&gt;\d\d)-(?&lt;d&gt;\d\d) (?&lt;hh&gt;\d\d):(?&lt;mm&gt;\d\d):(?&lt;ss&gt;\d\d).(?&lt;ms&gt;\d\d\d)/) || // 2021-11-12 06:53:11.230
      s.match(/(?&lt;hh&gt;\d\d):(?&lt;mm&gt;\d\d):(?&lt;ss&gt;\d\d).(?&lt;ms&gt;\d\d\d)/) || // 06:53:11.230
      s.match(/(?&lt;y&gt;\d\d\d\d)-(?&lt;m&gt;\d\d)-(?&lt;d&gt;\d\d) (?&lt;hh&gt;\d\d):(?&lt;mm&gt;\d\d):(?&lt;ss&gt;\d\d)/) || // 2021-11-12 06:53:11
      s.match(/(?&lt;hh&gt;\d\d):(?&lt;mm&gt;\d\d):(?&lt;ss&gt;\d\d)/) || // 06:53:11
      s.match(/(?&lt;m&gt;\d+)\/(?&lt;d&gt;\d+)\/(?&lt;y&gt;\d+), (?&lt;hh&gt;\d+):(?&lt;mm&gt;\d+):(?&lt;ss&gt;\d+)() (?&lt;ampm&gt;(AM|PM))?/) || // 10/26/2021, 9:43:06 PM
      s.match(/(?&lt;hh&gt;\d+):(?&lt;mm&gt;\d+):(?&lt;ss&gt;\d+) (?&lt;ampm&gt;(AM|PM))/); // 9:43:06 PM
  if (!match) return null;
  const y = parseInt(match.groups.y) || 1970;
  const m = parseInt(match.groups.m) || 1; // 1-based
  const d = parseInt(match.groups.d) || 1; // 1-based
  const hh = parseInt(match.groups.hh) + (match.groups.ampm == &apos;PM&apos; || match.groups.ampm == &apos;pm&apos; ? 12 : 0)
  const mm = parseInt(match.groups.mm);
  const ss = parseInt(match.groups.ss);
  const ms = parseInt(match.groups.ms) || 0;
  return new Date(Date.UTC(y, m-1, d, hh, mm, ss, ms)); // uses 0-based month, 1-based day
}

/**
 * We are given the non-null string name of the log we&apos;re currently processing,
 * and the time of the previous log entry (may be null of no previous entries
 * in this log had a time), and a list of non-blank lines followed by blank lines.
 * If the first line doesn&apos;t start with &apos;[&apos; then we must have been given trivia
 * and so return null.
 */
function parse_message(log, prev_time, lines) {
  // Cleanup: if we&apos;re given a message which doesn&apos;t start with [, it must have been the initial preamble, so we delete it.
  // Cleanup: if our message ends in newlines, we&apos;ll remove them.
  // Cleanup: if we don&apos;t even have anything left, we&apos;ll skip.
  while (lines.slice(-1)[0] == &quot;&quot;) {
    lines.pop();
  }
  if (lines.length == 0 || !line_starts_message(lines[0])) {
    return null;
  }

  const message = lines.join(&quot;\n&quot;);

  // Gather an initial contiguous sequence of &quot;tags&quot;.
  // A tag is something enclosed with square brackets, with optional whitespace after the closing square bracket,
  // that doesn&apos;t itself contain any brackets or braces or parentheses.
  // We strip leading and trailing whitespace from tags.
  let s = lines[0];
  let tags = [];
  {
    const match = s.match(/^([^\[ ]*) /);
    if (match) {
      tags.push(match[1]);
      s = s.slice(match[0].length);
    }
  }
  while (true) {
    const match = s.match(/^\[ *([^\]\{\}\(\)]+)\] */);
    if (!match) break;
    tags.push(match[1].replace(/ *$/, &quot;&quot;));
    s = s.slice(match[0].length);
  }

  s = s.replace(/^: */,&apos;&apos;);

  const line = s;

  // The optional &quot;title&quot; is a series of alphanumerics without punctuation
  let title = null;
  {
    const match = s.match(/^ *([A-Za-z0-9_][^:&apos;&quot;\{/\[\()]*)([:&apos;&quot;\{\[/\()]) */);
    if (match) {
      title = match[1].replace(/ *$/, &quot;&quot;);
      s = s.slice(match[0].length);
      if (match[2] != &quot;:&quot;) {
        s = match[2] + s;
      }
    } else {
      const match2 = s.match(/^ *([A-Za-z0-9_][^:&apos;&quot;\{/\[\()]*)$/);
      if (match2) {
        title = match2[1].replace(/ *$/, &quot;&quot;);
        s = &quot;&quot;;
      }
    }
  }

  let body = s;

  // Can we extract any filenames out of the rest of the line?
  let filename = null;
  {
    const match = (&quot; &quot; + s).match(/([ &apos;&quot;])(\/[0-9A-Za-z/_\-.]*)/);
    if (match) {
      filename = match[2].split(&quot;\\&quot;).pop().split(&quot;/&quot;).pop();
    }
  }

  // Can we extract json from the rest of the line plus all subsequent lines?
  let json = null;
  {
    // attempt 1: start json at the first { or [ we see on the first line, plus all subsequent lines
    let ji = s.indexOf(&quot;{&quot;);
    if (ji == -1) ji = s.indexOf(&apos;[&apos;);
    if (ji != -1) json = parse_json_relaxed(s.slice(ji) + &quot;\n&quot; + lines.slice(1).join(&quot;\n&quot;));
    // attempt 2: look only on subsequent lines
    if (json == null) json = parse_json_relaxed(lines.slice(1).join(&quot;\n&quot;));
  }

  // Does one of the tags look like a timestamp? or have the form &quot;...#...&quot;?
  // We&apos;ll turn tags from a list into an object, with a member &apos;anon&apos; for an
  // array of the unrecognized ones.
  let time = null;
  let id = null;
  let oldtags = tags;
  tags = { positional: [] };
  const first_tag = oldtags.length == 0 ? null : oldtags[0];
  if ([&apos;INFO&apos;,&apos;DEBUG&apos;,&apos;ERROR&apos;].includes(first_tag)) {
    tags[&apos;kind&apos;] = first_tag;
    oldtags.shift();
  }
  for (const tag of oldtags) {
    const match_time = tryParseLogTime(tag);
    if (match_time) {
      time = match_time;
    } else {
      const match_id = tag.match(/^([A-Za-z]*)#.*$/);
      if (match_id) {
        if (match_id[1] == &quot;&quot;) {
          id = tag;
        } else {
          tags[match_id[1]] = tag;
          id = id || tag;
        }
      } else {
        tags.positional.push(tag);
      }
    }
  }

  // LSP messages have a particular format.
  {
    const match = lines[0].match(
      /^\[Trace - (?&lt;time&gt;[^\]]*)\] (?&lt;dir&gt;(Sending|Received)) (?&lt;kind&gt;(request|response|notification)) &apos;(?&lt;method_and_id&gt;[^&apos;]*)&apos; *(?&lt;body&gt;.*)$/
    );
    const lsp_time = match ? tryParseLogTime(match.groups.time) : null;
    if (match &amp;&amp; lsp_time) {
      time = lsp_time;
      log = `${log == &quot;(default)&quot; ? &quot;&quot; : log + &apos;:&apos;}${match.groups.dir == &quot;Sending&quot; ? &quot;client&quot; : &quot;server&quot;}`;
      title = match.groups.method_and_id.replace(/ - \(.*\)$/,&apos;&apos;); // e.g. &apos;textDocument/didChange&apos;
      body = match.groups.body;
      json = lines
        .slice(1)
        .join(&quot;\n&quot;)
        .replace(/^(Result|Params|Error): /, &quot;&quot;);
      try {
        json = JSON.parse(json);
      } catch (e) {
        json = null; // includes the case &quot;No result returned&quot;
      }
      // Some traces have json {jsonrpc:, id:, params|result|error: }
      // Others merely have the params/result/error
      let root;
      let kind;
      if (json?.hasOwnProperty(&apos;jsonrpc&apos;)) {
        id = json.id;
        kind = id == null ? &quot;notification&quot; : json.result != null || json.error != null ? &quot;response&quot; : &quot;request&quot;;
        root = json.params;
      } else {
        const matchid = match.groups.method_and_id.match(/ - \((.*)\)$/);
        id = (matchid) ? matchid[1] : null;
        kind = match.groups.kind;
        root = json;
      }
      // ids generated by the server are in a different namespace from those generated by the client
      let originate_by_server = (log == &quot;server&quot; || log.endsWith(&quot;:server&quot;)) ? true : false;
      if (kind == &quot;response&quot;) originate_by_server = !originate_by_server;
      if (originate_by_server &amp;&amp; id != null) id = `s#${id}`;
      // cancelRequest notification is about this particular id
      if (title == &apos;$/cancelRequest&apos;) id = root.id;
      // for filename, heuristic is to pick either textDocument.uri, or the first didWatcheFilesChanged filename
      const change0 = root?.changes?.length &gt; 0 ? root?.changes[0] : null;
      const uri = root?.textDocument?.uri || root?.uri || change0?.uri;
      filename = uri?.split(&quot;\\&quot;).pop().split(&quot;/&quot;).pop();

      tags = { kind };
    }
  }

  // Some logs have timestamps that omit the year/month/day; they have only time-of-day.
  // To handle wraparound at midnight, we&apos;ll say that if a such subsequent message
  // is earlier that the previous one, then it must be one day ahead.
  if (time != null &amp;&amp; time.getUTCFullYear() == 1970 &amp;&amp; prev_time != null) {
    while (time &lt; prev_time) time.setUTCDate(time.getUTCDate() + 1);
  }
  time = time || prev_time;  

  return {
    log,
    message,
    tags,
    time,
    line,
    title,
    body,
    id,
    filename,
    json,
  };
}

/** Heuristic for whether this line starts a message.
 */
function line_starts_message(line) {
  return line.startsWith(&apos;[&apos;)
    || line.startsWith(&apos;INFO [&apos;)
    || line.startsWith(&apos;DEBUG [&apos;)
    || line.startsWith(&apos;ERROR [&apos;);
}

/**
 * Given the string name of a logfile we&apos;re processing (or &quot;(default)&quot; if it
 * lacks a name), and its content, parse it into a list of messages and 
 * return that list.
 */
function parse_log(log, lines) {
  // A log&apos;s text is a series of &quot;messages&quot; with trivia between them.
  // A message is defined as starting on a line whose first character
  // is &quot;[&quot;, followed by a series of non-blank lines which themselves
  // don&apos;t start with &quot;[&quot;.
  let messages = [];
  let prev_time = null;
  let acc = [];
  for (const line of lines) {
    if (line_starts_message(line)) {
      const m = parse_message(log, prev_time, acc);
      prev_time = m?.time || prev_time;
      messages.push(m);
      acc = [];
    }
    acc.push(line);
  }
  const m = parse_message(log, prev_time, acc);
  prev_time = m?.time || prev_time;
  messages.push(m);
  // Filter out all cases where parse_message return null for it just being trivia
  messages = messages.filter((m) =&gt; m != null);
  // Invariant: starting from the first message to have a parseable timestamp,
  // it and all subsequent messages have monotonically ascending timestamps,
  // and none of the earlier ones do, and prev_time is the timestamp of the last message.
  // We&apos;ll use that fact to backfill the timestamp-less messages if possible:
  for (const m of messages) {
    if (m.time == null) m.time = prev_time;
  }
  // Invariant: either every message has a timestamp, or none of them do.

  return messages;
}


/** If the log contains some messages that are fully-dated e.g. 2021-11-18, and
 * other messages maybe from an LSP trace which don&apos;t have dates and are stored
 * starting 1970-01-01, then this method rewrites the undated messages to start
 * at the earliest full date.
 * Note: some logs are entirely undated. They&apos;re skipped by this method.
*/
function reconcile_log_dates(messages) {
  // Context:
  // Some log formats include dates &quot;2021-11-12 14:44:00&quot; but LSP traces typically don&apos;t &quot;2:44:00 PM&quot;.
  // How can we support (1) scenario where the addendum has one log that starts on 2021-11-18 and
  // a fully-dated LSP trace that starts on 2021-11-19, the next day? (2) scenario where the user
  // loads an undated LSP trace and wants it to look reasonable? (3) scenario where the user
  // loads an undated LSP trace that starts on 2021-11-19 and then afterwards loads a fully-dated
  // other log that also starts on 2021-11-19 and wants to see them interleaved? (4) reverse
  // where the user first loads the fully-dated other log and then loads the undated LSP trace
  // where both start on the same day? -- That&apos;s what this method achieves.

  // But, when parsing a log, we &quot;increment the date&quot; if ever we see a time followed
  // by an earlier time, e.g. 23:50:05 followed by 00:02:03. If there was an undated
  // log with more than 365 such resets, its year won&apos;t be 1970 any longer, and
  // this logic will fail.
  let earliest = null;
  for (const m of messages) {
    if (m.time == null) continue;
    if (m.time.getUTCFullYear() == 1970) continue;
    if (earliest == null) earliest = m.time;
    if (m.time &lt; earliest) earliest = m.time;
  }
  if (!earliest) return;
  earliest = new Date(earliest);
  earliest.setUTCHours(0);
  earliest.setUTCMinutes(0);
  earliest.setUTCSeconds(0);
  earliest.setUTCMilliseconds(0);
  const offset = earliest.valueOf();
  // e.g. if first timestamp was &quot;2021-11-12 14:44:00&quot;, then offset is the number
  // of milliseconds to add to &quot;1970-01-01 09:17:00&quot; to get &quot;2021-11-12 09:17:00&quot;
  for (const m of messages) {
    if (m.time == null) continue;
    if (m.time.getUTCFullYear() != 1970) continue;
    m.time = new Date(m.time.valueOf() + offset);
  }
}

/** Given a list of messages, constructs and returns an autocomplete dictionary for it.
 *  Example: this list of messages
 *   [log1] foo {addr: &apos;hello&apos;, age: 47, cols: [1,2,3]}
 *   [log2] bar {addr: &apos;world&apos;, age: 53, cols: []}
 *   [log3] baz {addr: &apos;there&apos;, cols: []}
 * produces this dictionary:
 * { title: { hint:[string], nested: null},
 *   json: { hint:[object], nested: {
 *     addr: { hint:[string], nested:null},
 *     age: { hint:[num|undefined], nested:null},
 *     cols: [hint:[array], nested: {ELEMENT: {hint:[num],nested:null}}
 * }
 */
function build_dictionary(messages) {
  // We&apos;ll first construct everything &apos;positively&apos; from the members that are present
  let dictionary = {};
  if (messages.length == 0) return dictionary;
  let add;
  add = (dict, prop, value, allowRecurse) =&gt; {
    if (dict[prop] == null) dict[prop] = { hint: new Set(), nested: null };
    let type;
    if (value === null) type = &quot;null&quot;;
    else if (value === &quot;&quot;) type = &quot;empty_string&quot;;
    else if (value instanceof Date) type = &quot;Date&quot;;
    else type = typeof value;
    if (Array.isArray(value)) {
      if (dict[prop].nested == null) dict[prop].nested = {};
      for (const v of value) {
        add(dict[prop].nested, &quot;ELEMENT&quot;, v, true);
      }
    } else if (type == &quot;object&quot;) {
      if (allowRecurse) {
        if (dict[prop].nested == null) dict[prop].nested = {};
        for (const [k, v] of Object.entries(value)) {
          add(dict[prop].nested, k, v, true);
        }
      }
    } else {
      dict[prop].hint.add(type);
    }
  };
  for (const m of messages) {
    for (const [k, v] of Object.entries(m)) {
      add(dictionary, k, v, k == &quot;json&quot; || k == &quot;tags&quot;);
    }
  }

  // Now sprinkly in &apos;undefined&apos; for members that aren&apos;t always present
  let undef;
  undef = (dict, value) =&gt; {
    if (value == null || typeof value != &quot;object&quot;) value = {};
    for (const [k, v] of Object.entries(dict)) {
      if (k == &quot;ELEMENT&quot;) {
        if (!Array.isArray(value)) {
          v.hint.add(&quot;undefined&quot;);
        } else if (dict[&quot;ELEMENT&quot;].nested != null) {
          for (const e of value) {
            undef(dict[&quot;ELEMENT&quot;].nested, e);
          }
        }
      } else {
        if (!value.hasOwnProperty(k)) v.hint.add(&quot;undefined&quot;);
        if (v.nested != null) undef(dict[k].nested, value[k]);
      }
    }
  };
  for (const m of messages) {
    undef(dictionary, m);
  }

  // Now combine all those &apos;primitive&apos; hints into a hint, and provide extra hints for the top level
  let hintify;
  hintify = (dict) =&gt; {
    for (const [k, v] of Object.entries(dict)) {
      let types = [...v.hint];
      if (v.nested != null) {
        if (v.nested.hasOwnProperty(&quot;ELEMENT&quot;)) {
          types.push(&quot;array&quot;);
          if (Object.entries(v.nested).length &gt; 1) types.push(&quot;object&quot;);
        } else {
          types.push(&quot;object&quot;);
        }
      }
      v.hint = types.length == 0 ? &quot;none&quot; : types.join(&quot; | &quot;);
      if (v.nested != null) hintify(v.nested);
    }
  };
  hintify(dictionary);
  dictionary.log.hint +=
    &apos;  -- which logfile it came in; for lsp is &quot;client / server&quot;&apos;;
  dictionary.message.hint += &quot;  -- the entire message&quot;;
  dictionary.tags.hint +=
    &quot;  -- a list of any [...] tags at the start of the message, other than time-like ones&quot;;
  dictionary.time.hint +=
    &quot;  -- one of the timelike [...] tag from the start of the message&quot;;
  dictionary.line.hint +=
    &quot;  -- the first line of the message, after all the tags&quot;;
  dictionary.title.hint +=
    &apos;  -- if line had the form &quot;title: body&quot; then this is the title&apos;;
  dictionary.body.hint +=
    &quot;  -- this is however much of line after the title has been removed&quot;;
  dictionary.id.hint +=
    &quot;  -- best-guess as to the most important id; for lsp cancellation the id being cancelled&quot;;
  dictionary.filename.hint +=
    &quot;  --  best-guess as to an (unqualified) filename found in the message&quot;;
  dictionary.json.hint +=
    &quot;  -- best-guess if the end of the message looked like json object or array&quot;;
  return dictionary;
}

// ===================================================================
// ===================================================================
// ===================================================================
// ===================================================================
// HELPERS
// ===================================================================
// ===================================================================
// ===================================================================
// ===================================================================

/** Given a filename like &quot;/foo/bar/fred.txt&quot; returns &quot;fred&quot;
 */
function logname_from_filepath(filepath) {
  const filename = filepath.split(&quot;\\&quot;).pop().split(&quot;/&quot;).pop();
  const extension = filename.lastIndexOf(&quot;.&quot;);
  if (extension &gt;= 3 &amp;&amp; extension &lt; filename.length - 3)
    return filename.substring(0, extension);
  return filename;
}

/** Attempt to parse it first as proper json, else as heuristic relaxed json.
 * Returns null if it couldn&apos;t be parsed.
 * CARE: we must never &apos;eval&apos; log input. That&apos;s why we use regexps to
 * approximate turning relaxed json into proper json.
 */
function parse_json_relaxed(s) {
  if (!s.match(/^ *[\[\{]/)) return null;
  try { return JSON.parse(s); } catch (e) {}
  // relaxed json: we&apos;ll use double-quotes not single-quotes for keys and values
  // This will also affect single-quotes inside values, but it&apos;s the log&apos;s
  // fault for using relaxed json in the first place so you get what you get...
  s = s.replace(/&apos;/g, &apos;&quot;&apos;);
  // we&apos;ll escape any colons inside values
  s = s.replace(/:\s*&quot;([^&quot;]*)&quot;/g, function(match, p1) {
    return &apos;: &quot;&apos; + p1.replace(/:/g, &apos;@colon@&apos;) + &apos;&quot;&apos;;
  })
  // put quotes around unquoted identifiers
  s = s.replace(/([a-z0-9A-Z_]+):/g, &apos;&quot;$1&quot;: &apos;);
  // undefined
  s = s.replace(/&quot;([a-z0-9A-Z_]+)&quot;:\s*undefined,?/g, &apos;&apos;);
  // unescape colons
  s = s.replace(/@colon@/g, &apos;:&apos;);
  try { return JSON.parse(s); } catch (e) {}
  return null;
}

/** Given a string, renders it suitable for html e.g. `&lt;p&gt;${esc(s)}&lt;/p&gt;`
 */
function esc(s) {
  if (s == null) return &quot;&amp;nbsp;&quot;;
  return String(s)
    .replace(/&amp;/g, &quot;&amp;amp;&quot;)
    .replace(/&lt;/g, &quot;&amp;lt;&quot;)
    .replace(/&gt;/g, &quot;&amp;gt;&quot;)
    .replace(/&quot;/g, &quot;&amp;quot;&quot;)
    .replace(/&apos;/g, &quot;&amp;apos;&quot;);
}

/** Pads a number with leading zeros to take it up to length 2,
 * or some other number specified in &apos;n&apos;. */
function pad2(s, n) {
  s = String(s);
  while (s.length &lt; (n || 2)) s = &quot;0&quot; + s;
  return s;
};

/** Given a Date object, returns an dateless and millisecondless &quot;18:23:15&quot; time to show
 * next to the message
 */
 function formatCompactTime(time) {
  const hh = pad2(time.getUTCHours());
  const mm = pad2(time.getUTCMinutes());
  const ss = pad2(time.getUTCSeconds());
  return `${hh}:${mm}:${ss}`;
}


/** We strive to display time-control with just times &quot;18:23:15&quot; even though logs have
 * full dates &quot;2021-11-13 18:23:15&quot;, and some undated logs like LSP have epoch-relative
 * full dates &quot;1970-01-01 18:23:15&quot;. We do this with reference to a &quot;reference time&quot;
 * which is the date part &quot;2021-11-13 / 1970-01-01&quot; of the first log message to have a time.
 * This function returns that reference time.
 */
function referenceForTimeControl(messages) {
  const m = messages.find(m =&gt; m.time != null);
  if (!m) return null;
  let t = new Date(m.time);
  t.setUTCHours(0);
  t.setUTCMinutes(0);
  t.setUTCSeconds(0);
  t.setUTCMilliseconds(0);
  return t;
}

/** Given a Date object, returns something for the time controls to show.
 * We make use of a &quot;reference date&quot; derived from the messages list.
 * For instance, given reference date &quot;2021-11-13&quot; then we&apos;d display
 * &quot;2021-11-14 18:23:15.123&quot; as &quot;18:23:15.123 (+1day)&quot;
 * Note: this also works if the reference date is &quot;1970-01-01&quot; indicating
 * an undated log, and the date we&apos;re given is &quot;1970-01-01&quot;
 * If no reference time is provided, then the user has no business using
 * time filters, so we&apos;ll solely display the time part.
 */
function formatTimeControl(time, messages) {
  const ms = time.getUTCMilliseconds() == 0 ? &quot;&quot; : &quot;.&quot; + pad2(time.getUTCMilliseconds(), 3);
  const hms = `${formatCompactTime(time)}${ms}`;
  const ref = referenceForTimeControl(messages);
  if (ref == null) return hms;
  // Calculate number of days between &apos;ref&apos; and &apos;time&apos;
  // We&apos;ll do it by constructing UTC objects, since they don&apos;t have daylight saving
  // and hence each day is exactly 24hrs long always.
  const start = Date.UTC(ref.getUTCFullYear(), ref.getUTCMonth(), ref.getUTCDate());
  const end = Date.UTC(time.getUTCFullYear(), time.getUTCMonth(), time.getUTCDate());
  const plusDays = Math.round((end - start) / (1000 * 60 * 60 * 24));
  if (plusDays == 0) return hms;
  return `${hms} (${plusDays &gt; 0 ? &quot;+&quot; : &quot;-&quot;}${Math.abs(plusDays)}day${Math.abs(plusDays) == 1 ? &quot;&quot; : &quot;s&quot;})`;
}

/** Given a string from a time control, parses it into a time. This is recognized:
 *   null/empty string -&gt; returns null
 *   yyyy-mm-dd hh:mm:ss(.mmm)?
 * If the messages list provides a reference date, then we also recognize:
 *   hh:mm:ss(.mmm)? -&gt; uses yyyy-mm-dd from reference date
 *   hh:mm:ss(.mmm)? (+|-D ?days?) -&gt; D days before or after the reference date
 * If a Date object &quot;relativeTo&quot; is provided then a few additional formats are recognized:
 *   (+|-)N s(econds)?|m(inutes)?|h(ours)?
 * If the string can&apos;t be parsed, throw a descriptive human-readable exception text
 */
function parseTimeControl(time, messages, relativeTo) {
  if (time == null || time == &quot;&quot;) return null;
  if (time.match(/^\d\d\d/) || time.match(/^\d+\//)) {
    // starts with year
    const match = time.match(
      /^(?&lt;y&gt;\d+)-(?&lt;m&gt;\d+)-(?&lt;d&gt;\d+) (?&lt;hh&gt;\d+):(?&lt;mm&gt;\d+):(?&lt;ss&gt;\d+)(\.(?&lt;ms&gt;\d\d\d))?$/
    );
    if (!match) throw new Error(&quot;expected yyyy-mm-dd hh:mm:ss&quot;);
    const y = parseInt(match.groups.y);
    const m = parseInt(match.groups.m); // 1-based
    const d = parseInt(match.groups.d); // 1-based
    const hh = parseInt(match.groups.hh);
    const mm = parseInt(match.groups.mm);
    const ss = parseInt(match.groups.ss);
    const ms = parseInt(match.groups.ms) || 0;
    return new Date(Date.UTC(y, m-1, d, hh, mm, ss, ms)); // uses 0-based month, 1-based day
  } else if (time.match(/^\d/)) {
    // starts with hours
    const match = time.match(/^(?&lt;hh&gt;\d+):(?&lt;mm&gt;\d+):(?&lt;ss&gt;\d+)(\.(?&lt;ms&gt;\d\d\d))?(?&lt;rest&gt;.*)$/)
    if (!match) throw new Error(&quot;expected hh:mm:ss&quot;)
    const ref = referenceForTimeControl(messages);
    if (ref == null) throw new Error(&quot;no log messages have any times in them&quot;);
    const hh = parseInt(match.groups.hh);
    const mm = parseInt(match.groups.mm);
    const ss = parseInt(match.groups.ss);
    const ms = parseInt(match.groups.ms) || 0;
    let t = new Date(Date.UTC(ref.getUTCFullYear(), ref.getUTCMonth(), ref.getUTCDate(), hh, mm, ss, ms));
    if (!match.groups.rest) return t;
    const match2 = match.groups.rest.match(/^ \((?&lt;plusminus&gt;\+|-)?(?&lt;days&gt;\d+) ?(d|day|days)?\)$/);
    if (!match2) throw new Error(&quot;expected hh:mm:ss (+Ndays)&quot;);
    const plusDays = match2.groups.days * (match2.groups.plusminus == &quot;+&quot; ? 1 : -1);
    t.setUTCDate(t.getUTCDate() + plusDays)
    return t;
  } else if (time.charAt(0) == &quot;+&quot; || time.charAt(0) == &quot;-&quot;) {
    if (relativeTo == null) throw new Error(&quot;need start for +N relative times&quot;);
    const match = time.match(
      /^(\+|-)(\d+) ?(s|sec|secs|second|seconds|m|min|mins|minute|minutes|h|hour|hours)$/
    );
    if (!match) throw new Error(&quot;expected +N h|m|s&quot;);
    const n = parseInt(match[2]) * (time.charAt() == &quot;+&quot; ? 1 : -1);
    const unit = match[3].charAt(0);
    const r = new Date(relativeTo.getTime());
    if (unit == &quot;s&quot;) r.setUTCSeconds(r.getUTCSeconds() + n);
    else if (unit == &quot;m&quot;) r.setUTCMinutes(r.getUTCMinutes() + n);
    else if (unit == &quot;h&quot;) r.setUTCHours(r.getUTCHours() + n);
    else throw new Error(&quot;unexpected time unit&quot;);
    return r;
  } else {
    throw new Error(`expected hh:mm:ss or +N h|m|s`);
  }
}

/** FNB-1a hash - given a string, produces a positive number.
 * From https://gist.github.com/vaiorabbit/5657561
 */
 function hash(s) {
let hash = 0x811c9dc5;
  for (let i=0; i&lt;s.length; i++) {
    hash ^= s.charCodeAt(i);
    hash += (hash &lt;&lt; 1) + (hash &lt;&lt; 4) + (hash &lt;&lt; 7) + (hash &lt;&lt; 8) + (hash &lt;&lt; 24);
  }
  return Math.abs(hash);
}

/** Given a string like &quot;id + title&quot;, this returns a function which
 * takes message &apos;m&apos; and returns the result of evaluating the string
 * If there are errors constructing the function, e.g. parse errors,
 * they&apos;re not reported immediately; instead we return a function which
 * will throw that error. In this way parse errors are produced lazily
 * just like evaluation errors.
 * Security notice: these strings come from the URL query string, which is
 * an untrusted source -- imagine if the string were &apos;new XMLHttpRequest().put()&apos;.
 * We&apos;re going to restrict the string from accessing &apos;this&apos; nor any top-level
 * symbols other than a whitelist. https://stackoverflow.com/a/69750236
 */
function make_fn(expr) {
  const whitelist = [&apos;Math&apos;, &apos;Array&apos;, &apos;String&apos;, &apos;JSON&apos;]; // Warning: not &apos;Function&apos;
  let scope = {};
  for (let obj = window; obj; obj = Object.getPrototypeOf(obj)) {
    Object.getOwnPropertyNames(obj).forEach(name =&gt; scope[name] = undefined);
  }
  whitelist.forEach(name =&gt; scope[name] = window[name]);
  try {
    const fn = Function(
      &quot;scope&quot;,
      &quot;log&quot;,
      &quot;message&quot;,
      &quot;tags&quot;,
      &quot;time&quot;,
      &quot;line&quot;,
      &quot;title&quot;,
      &quot;body&quot;,
      &quot;id&quot;,
      &quot;filename&quot;,
      &quot;json&quot;,
      &quot;with (scope) return &quot; + expr
    ).bind({});
    return (m) =&gt;
      fn(
        scope,
        m.log,
        m.message,
        m.tags,
        m.time,
        m.line,
        m.title,
        m.body,
        m.id,
        m.filename,
        m.json
      );
  } catch (e) {
    return (m) =&gt; {
      throw e;
    };
  }
}

/** Given hue, saturation, lightness each in range [0..1],
 * returns an rgb string &quot;#rrggbb&quot; for that color.
 */
function hsl(h, s, l) {
  let r, g, b;
  if (s == 0) {
    r = g = b = l;
  } else {
    const f = (p, q, t) =&gt; {
      if (t &lt; 0) t += 1;
      else if (t &gt; 1) t -= 1;
      if (t &lt; 1 / 6) return p + (q - p) * 6 * t;
      else if (t &lt; 1 / 2) return q;
      else if (t &lt; 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      else return p;
    };
    let q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;
    let p = 2 * l - q;
    r = f(p, q, h + 1 / 3);
    g = f(p, q, h);
    b = f(p, q, h - 1 / 3);
  }
  const x = (i) =&gt; {
    let s = Math.round(i * 255).toString(16);
    while (s.length &lt; 2) s = &quot;0&quot; + s;
    if (s.length &gt; 2) s = &quot;FF&quot;;
    return s;
  };
  return `#${x(r)}${x(g)}${x(b)}`;
}&lt;/script&gt;@"></iframe>
</body>
</html>
<!--
