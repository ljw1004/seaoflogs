<!DOCTYPE html>
<html>
<!-- The part of this file up to the closing </html> tag is (c) Lucian Wischik -->
<head>
  <title>Sea of logs</title>
  <style type="text/css">
    html {
      height: 100%;
      width: 100%;
      margin: 0;
    }

    body {
      margin: 0;
      height: 100%;
      width: 100%;
      background-color: white;
      color: black;
    }

    table {
      height: 100%;
      width: 100%;
      border-collapse: collapse;
    }

    #left {
      position: fixed;
      width: 20%;
      height: 100%;
      background-color: lightgray;
      vertical-align: top;
    }

    #right {
      margin: 0;
      margin-left: 20%;
      width: 80%;
      font-size: small;
      padding: 0;
    }

    #title a {
      color: black;
      text-decoration: none;
    }

    #title a:visited {
      color: black;
    }

    .message,
    .background {
      margin: 0.5ex;
    }

    .messagetext {
      cursor: grab;
    }

    .messagetime {
      cursor: zoom-in;
    }

    #backgrounds,
    #messages {
      position: absolute;
      width: 80%;
      height: 100%;
      margin: 0;
    }

    #connectors {
      position: absolute;
      width: 80%;
      height: 100%;
      margin: 0;
    }

    #left textarea {
      font-family: sans-serif;
      width: 92%;
    }

    .messagetime,
    .logcount {
      font-size: xx-small;
      color: gray;
      font-family: monospace;
    }

    .error {
      color: red;
      background-color: #500000;
      border: solid thin red;
      margin: 0.5ex 1em 0.5ex 0.2em;
      font-size: small;
      padding: 0.5ex;
    }

    #popup {
      font-size: x-small;
      font-family: monospace;
      position: absolute;
      white-space: pre;
      display: none;
      max-width: 50em;
      max-height: 20em;
      overflow: auto;
      border: solid thin black;
      background-color: #F0F0F0;
    }

    #menu {
      position: fixed;
      display: none;
    }

    #menu select::-webkit-scrollbar {
      display: none;
    }

    #menu select::-moz-scrollbar {
      display: none;
    }

    #menu select::-o-scrollbar {
      display: none;
    }

    #menu select::-google-ms-scrollbar {
      display: none;
    }

    #menu select::-khtml-scrollbar {
      display: none;
    }

    #menu #autocomplete {
      font-size: small;
      background-color: #f0f0f0;
      border: solid thin black;
      padding: 0.2ex;
      z-index: 100;
      box-shadow: 0 0 1ex 1ex black;
    }

    .autocomplete_name {
      padding-right: 1em;
    }

    .autocomplete_hint {
      font-style: italic;
      color: darkgreen;
    }

    #load {
      opacity: 0;
      position: absolute;
      z-index: -1;
    }

    #loadbutton {
      font-size: smaller;
      cursor: arrow;
      background-color: #f0f0f0;
      padding: 0.2ex;
      border: solid thin black;
      border-radius: 0.5ex;
    }

    #loadbutton:hover {
      background-color: #f0f0FF;
    }
  </style>
  <script type="text/javascript">
// ===================================================================
// ===================================================================
// ===================================================================
// ===================================================================
// GLOBAL MUTABLE STATE
// In addition to these variables, the URL query params also provide
// one state field 'details' used by render_popup to know the details
// function.
// ===================================================================
// ===================================================================
// ===================================================================
// ===================================================================

/** a global list of all messages from all known logs, even if they're hidden (unchecked).
 * It is initially empty; it is only ever appended, upon window.onload and clicking the
 * "load" button.
 */
 var global_messages = [];

/** global autocomplete dictionary, constructed by control_handler after re-rendering
 * current messages. It is a map {member_name -> {hint:string, nested:dictionary}}
 * We treat an array [1,2,3] as a dictionary with a single member {ELEMENT -> [element_types]}
 */
var global_current_dictionary = {};

/** this is a timer to debounce edits and resizes, used by control_handler
 */
var global_debounce_timeout = null;

/** resize_expected_height is the last height to have been computed for the messages div;
 * control_handler detects upon scroll that if the current height is different, then all
 * svg lines will have to be recomputed
 */
var global_resize_expected_height = null;

/** If a popup is up, this is its index (into the unfiltered/unsorted global_messages)
 */
var global_popup_message_index = null;

// ===================================================================
// ===================================================================
// ===================================================================
// ===================================================================
// ENTRY POINTS
// ===================================================================
// ===================================================================
// ===================================================================
// ===================================================================

// We'll ingest addendum logs upon startup, and update controls from the uri:
window.onload = (event) => window_load_handler(event);
// If resizes causes messages to wrap, we'll need to re-render them:
window.onresize = (event) => control_handler(event);
// If user presses Escape, hide all active pops:
document.onkeydown = (event) => hide_popups_handler(event);
// We synthesize background colors lazily with this function:
document.addEventListener("scroll", () => render_missing_backgrounds());

// ===================================================================
// ===================================================================
// ===================================================================
// ===================================================================
// EVENT HANDLERS
// ===================================================================
// ===================================================================
// ===================================================================
// ===================================================================

/** Called by window.onload. Job is to ingest any logs in the addendum,
 * and set up controls from the URI params.
 */
function window_load_handler(event) {
  global_messages = [];

  // The addendum is whatever was appended to the end of this source file, after the final <!--
  // Even though we wrote the final <!-- after the </html>, Chrome actually promotes that
  // comment tag to be the last child of the body. Thanks, Chrome!
  const addendum = [...document.getElementsByTagName("body")[0].childNodes]
    .filter((c) => c.nodeType == Node.COMMENT_NODE)
    .reverse()[0].data;
  var acc = [];
  var log = "(default)";
  var has_named_logs = false;
  const lines = addendum.split(/\r?\n/);
  for (const line of lines) {
    const match = line.match(/^==> (.*) <==$/);
    if (match) {
      global_messages = global_messages.concat(parse_log(log, acc));
      log = logname_from_filepath(match[1]);
      acc = [];
      has_named_logs = true;
    } else {
      acc.push(line);
      continue;
    }
  }
  global_messages = global_messages.concat(parse_log(log, acc));
  render_controls();
  document.getElementById("logs").style.display = has_named_logs
    ? "block"
    : "none";
  document.getElementById(
    "loading"
  ).innerText = `Loading ${global_messages.length} messages...`;
  const params = new URLSearchParams(window.location.search);
  write_controls(params);
  control_handler(event);
}

/** Called by a click on the Load button. Job is to ingest the log,
 * update controls, and re-render.
 */
function load_button_handler(event) {
  const [file] = document.querySelector("input[type=file]").files;
  if (!file) return;
  const reader = new FileReader();
  reader.addEventListener(
    "load",
    (event) => {
      const log = logname_from_filepath(file.name);
      const lines = reader.result.split(/\r?\n/);
      global_messages = global_messages.concat(parse_log(log, lines));
      render_controls();
      document.getElementById("logs").style.display = "block";
      control_handler(event);
    },
    false
  );
  reader.readAsText(file);
}

/** This is called on changes to controls. Its main response is to recompute
 * the message-list. This method debounces the recoputation.
 * (1) If the user makes a change in a textarea control e.g. the filter or the text,
 *     then we will recompute the message-list. Also we'll adjusts the height
 *     of the textarea to fit everything.
 * (2) If the user clicks a log button or dropdown, or alters the time,
 *     then again we'll recompute the message-list.
 * (3) If the user resizes the window, then surprisingly we might need a debounced
 *     recompute of the message-list. In particular if the resize causes
 *     messages to wrap differently (detected by the new height of the bottom
 *     message to be different from what it was before) then all backgrounds and
 *     lines in the display must be thrown out and recomputed.
 * (4) If the user clicks the load button, then after the load we do a debounced
 *     recompute of the message-list
 * (5) On window.load, after parsing the addendum, we do a debounced recompute
 *     of the message-list
 */
function control_handler(event) {
  // Commonly, we'll use a timeout that's snappy for small message-lists
  // that can be recomputed quickly, and slower for larger lists.
  const displayed_message_length =
    document.getElementById("messages").childElementCount;
  const message_burden =
    displayed_message_length == 0
      ? global_messages.length
      : displayed_message_length;
  var timeout = message_burden > 10000 ? 500 : message_burden > 2000 ? 150 : 50;
  var update_url = true;

  if (event.type == "load") {
    // upon load, we only have a short timeout to allow the screen to render;
    // we want the messages to be recomputed as soon as rendering is done.
    timeout = 1;
  } else if (event.type == "resize") {
    // upon window-resize, if the wrapping (hence, vertical height) of the message-list
    // hasn't changed then there's no need to recompute anything.
    const lastChild = document.getElementById("messages").lastChild;
    const height =
      lastChild == null ? 0 : lastChild.offsetTop + lastChild.offsetHeight;
    if (height == global_resize_expected_height) return;
    // If we do need to recompute in response to window-resize, we'll do so with
    // a fairly high timeout.
    timeout = 250;
    update_url = false;
  } else if (
    event.type == "change" &&
    (event.target.id == "select_start" || event.target.id == "select_end")
  ) {
    // user clicked on a start/end dropdown. That has already had the effect of updating
    // the start/end inputs, but bypassed their normal firing of events, which is why
    // we handle it.
    // There's no need for debouncing here.
    timeout = 1;
  } else if (event.type == "change" && event.target.id == "time_menu") {
    // user clicked on a time popup. Again, no need for debouncing.
    timeout = 1;
  } else if (
    event.type == "input" &&
    (event.target.id == "input_start" || event.target.id == "input_end")
  ) {
    // user typed in the time boxes. Uses normal debounce.
  } else if (event.type == "input" && event.target.tagName == "TEXTAREA") {
    // User typed in a textbox.
    // We'll immediately adjust the size of the textbox to fit whatever's there,
    // and update the autocomplete, and kick off a recompute using the normal debounce.
    event.target.style.height = "";
    event.target.style.height = event.target.scrollHeight + "px";
  } else if (
    event.type == "change" &&
    (event.target.id.startsWith("logcheck") ||
      event.target.id.startsWith("logalign"))
  ) {
    // clicked on a checkbox or an alignment button for logs.
    // We'll use standard debounce.
  } else {
    throw new Error(`control_handler ${event.target.id || "?"}.${event.type}`);
  }

  // update URL
  const params = read_controls();
  if (update_url) {
    // If there were params then we want '<url>?params'.
    // We can do this just by setting the url to '?params' and the browser will fill in the url.
    // If there were no params then we'd like to have just '<url>' without params.
    // Only way to do this is to provide the actual url; an empty string won't do.
    const url =
      [...params.keys()].length == 0
        ? String(window.location).replace(/\?.*$/, "")
        : "?" + params.toString();
    history.replaceState(null, null, url);
  }

  clearTimeout(global_debounce_timeout);
  global_debounce_timeout = setTimeout(() => {
    // figure out the controls
    const filter = params.has("filter")
      ? params.get("filter")
      : defaults.filter;
    const start = params.has("start") ? params.get("start") : defaults.start;
    const end = params.has("end") ? params.get("end") : defaults.end;
    const text = params.has("text") ? params.get("text") : defaults.text;
    const id = params.has("id") ? params.get("id") : defaults.id;
    const color = params.has("color") ? params.get("color") : defaults.color;
    const filter_fn = make_fn(filter || "true");
    const filter2_fn = (m) => {
      const key = `log_${m.log}`;
      const def = m.log == "server" ? defaults.log_server : defaults.log;
      const value = params.has(key) ? params.get(key) : def;
      if (value.startsWith("hide_")) return false;
      return filter_fn(m);
    };
    const align_fn = (m) => {
      const key = `log_${m.log}`;
      const def = m.log == "server" ? defaults.log_server : defaults.log;
      const value = params.has(key) ? params.get(key) : def;
      return value.replace(/^hide_/, "");
    };
    const text_fn = make_fn(text);
    const id_fn = make_fn(id);
    const color_fn = make_fn(color);
    var start_time = null,
      end_time = null,
      time_exn = null;
    if (start.charAt(0) == "-") {
      try {
        end_time = parseTime(end);
      } catch (e) {
        time_exn ||= e;
      }
      try {
        start_time = parseTime(start, end_time);
      } catch (e) {
        time_exn ||= e;
      }
    } else {
      try {
        start_time = parseTime(start);
      } catch (e) {
        time_exn ||= e;
      }
      try {
        end_time = parseTime(end, start_time);
      } catch (e) {
        time_exn ||= e;
      }
    }
    // render into html
    const { messages, filter_exn } = filter_and_sort_messages(
      global_messages,
      filter2_fn,
      start_time,
      end_time
    );
    const { text_exn, id_exn, color_exn } = render_messages(
      messages,
      text_fn,
      id_fn,
      color_fn,
      align_fn
    );
    render_error(document.getElementById("error_filter"), filter_exn);
    render_error(document.getElementById("error_time"), time_exn);
    render_error(document.getElementById("error_text"), text_exn);
    render_error(document.getElementById("error_id"), id_exn);
    render_error(document.getElementById("error_color"), color_exn);
    render_missing_backgrounds();
    // update or hide the persistent details popup
    const mindex = messages.findIndex(
      (m) => m.gindex == global_popup_message_index
    );
    if (mindex == -1) render_popup(null);
    else render_popup(document.getElementById("messages").children[mindex]);
    // set some global values
    for (var m of messages) {
      delete m.gindex;
      delete m.filter;
    }
    global_current_dictionary = build_dictionary(messages);
    const lastChild = document.getElementById("messages").lastChild;
    global_resize_expected_height =
      lastChild == null ? 0 : lastChild.offsetTop + lastChild.offsetHeight;
  }, timeout);
}

/** called by a messagetext's onclick handler, for
 * when the user clicks on a message to toggle its details popup.
 */
function message_handler(event, messageDiv, gindex) {
  event.stopPropagation();
  document.getElementById("menu").style.display = "none";
  if (global_popup_message_index == gindex) {
    render_popup(null);
  } else {
    global_popup_message_index = gindex;
    render_popup(messageDiv);
  }
}

/** Called by messagetime's onclick handler, for when
 * the user clicks on a time to populate start/end times
 */
function time_handler(event, time) {
  event.stopPropagation();
  render_popup(null);
  const menu = document.getElementById("menu");
  menu.style.top = `${event.clientY}px`;
  menu.style.left = `${event.clientX}px`;
  menu.style.display = "block";
  var html = `<select id='time_menu' multiple size=2><option value='start'>set start</option><option value='end'>set end</option></select>`;
  menu.innerHTML = html;
  const select = menu.getElementsByTagName("select")[0];
  select.addEventListener("change", (event) => {
    menu.style.display = "none";
    const value = select.options[select.selectedIndex].value;
    const input =
      value == "end"
        ? document.getElementById("input_end")
        : document.getElementById("input_start");
    input.value = formatTime(time, "full");
    control_handler(event);
  });
}

/** Called by keyup, click and focus events on a textarea.
 * Its job is to show or hide the autocomplete popup as appropriate.
 * Keyup covers typing and cursoring.
 * Click covers when you click on it to focus, and also when you click to reposition the caret.
 * Focus covers when you click on it to focus, and also when you tab to focus.
 * We often end up getting both Click and Focus e.g. when we gain focus from elsewhere. No matter.
 */
function autocomplete_handler(event) {
  if (event.type == "keyup" && event.key == "Escape") {
    // this handler is invoked to show autocomplete in response to keystrokes,
    // but if the keystroke was an escape then we won't!
    return;
  }
  // This is the entire text leading up to the caret:
  var text = event.target.value.substring(0, event.target.selectionStart);
  // We won't be fancy about nesting, but we will track
  // whether there's an unbalanced number of string quote delimeters
  if (
    text.split('"').length % 2 == 0 ||
    text.split("'").length % 2 == 0 ||
    text.split("`").length % 2 == 0
  )
    text = "";
  // Replace all [...] with .ELEMENT and replace all ?. with .
  text = text.replace(/\[[^\]]*\]/g, ".ELEMENT");
  text = text.replace(/\?\./g, ".");
  // Find the longest identifier+dot string leading to the caret
  const match = text.match(
    /(([a-zA-Z_][a-zA-Z0-9_]*\.)*[a-zA-Z_][a-zA-Z0-9_]*\.?)$/
  );
  text = match ? match[1] : "";
  const identifiers = text.split(".");
  // Walk the identifier chain to find autocomplete up to the second-last identifier in the chain.
  var current = global_current_dictionary;
  for (var i = 0; current != null && i < identifiers.length - 1; i++) {
    current = current[identifiers[i]]?.nested;
  }
  if (current == null) {
    menu.style.display = "none";
    return;
  }
  // The last identifier in the chain is the one that the caret is currently on,
  // e.g. for "foo.|" the last identifier will be the empty string, and for "foo|" it will be "foo".
  // We'll use it as a filter to only show some options.
  var filter = identifiers.pop();
  var html = `<table id='autocomplete'>`;
  for (const [k, v] of Object.entries(current)) {
    if (k.startsWith(filter)) {
      html += `<tr><td class="autocomplete_name">${
        k == "ELEMENT" ? "[]" : esc(k)
      }</td><td class="autocomplete_hint">${esc(v.hint)}</td></tr>`;
    }
  }
  html += `</table>`;
  // And render it!
  const menu = document.getElementById("menu");
  menu.innerHTML = html;
  menu.style.display = "block";
  const { x, y } = boundPopup(menu, event.target, "left");
  menu.style.top = `${y}px`;
  menu.style.left = `${x + event.target.offsetWidth}px`;
}

/** Called by the "body" onclick handler, for when the
 * user clicks in the background to dismiss any popups.
 * Also called by the document keydown event handler, for
 * when the user presses escape to dismiss popups.
 */
function hide_popups_handler(event) {
  var dismiss_menu = false;
  var dismiss_popup = false;
  if (event.type == "keydown" && event.key == "Escape") {
    // will dismiss them both
    dismiss_menu = true;
    dismiss_popup = true;
  } else if (event.type == "click") {
    // the time menu will be dismissed by any click not on it
    // the autocomplete popup will be dismissed by any click not on it and not on a textarea
    const menu = document.getElementById("menu");
    if (event.target.offsetParent != menu) dismiss_menu = true;
    if (
      menu.firstChild?.id != "time_menu" &&
      event.target.tagName == "TEXTAREA"
    ) {
      dismiss_menu = false;
    }
    // the details-popup is more sticky: clicking in the #left panel won't dismiss it
    var parent = event.target;
    while (parent != null && parent.id != "left") parent = parent.offsetParent;
    dismiss_popup = parent == null;
  }
  if (dismiss_menu) menu.style.display = "none";
  if (dismiss_popup) render_popup(null);
}

// ===================================================================
// ===================================================================
// ===================================================================
// ===================================================================
// RENDERING FUNCTIONS INTO THE HTML
// ===================================================================
// ===================================================================
// ===================================================================
// ===================================================================

/** Figures out a good {x,y} for the popup to display related to the element.
 * If align is 'right' then it will align to the right of the element,
 * otherwise to the left.
 */
function boundPopup(popup, element, align) {
  const rPopup = popup.getBoundingClientRect();
  const rElement = element.getBoundingClientRect(); // relative to screen
  const rWindow = { right: window.innerWidth, bottom: window.innerHeight };
  // popup will be offset to the left of right-column, or offset to right of left-column
  // but clipped within bounds
  var x = align == "right" ? rElement.right - rPopup.width : rElement.left;
  if (x + rPopup.width > rWindow.right) x = rWindow.right - rPopup.width;
  if (x < 0) x = 0;
  // popup will go underneath element if it fits, else above if it fits, else underneath
  var y =
    rElement.bottom + rPopup.height < rWindow.bottom
      ? rElement.bottom
      : rElement.top - rPopup.height >= 0
      ? rElement.top - rPopup.height
      : rElement.bottom;
  return { x, y };
}

/** Either shows or hides 'element' according to whether to show the exception
 */
function render_error(element, exn) {
  element.innerText = String(exn);
  element.style.display = exn == null ? "none" : "block";
}

/** Renders this list of messages into html elements #messages, #svg, #backgrounds.
 * Depends on the input messages having additional 'gindex' and 'filter' properties.
 * Returns {text_exn, id_exn, color_exn} for any errors encountered
 */
function render_messages(messages, text_fn, id_fn, color_fn, align_fn) {
  var text_exn = null;
  var id_exn = null;
  var color_exn = null;

  // This is where we'll render to
  const messagesElement = document.getElementById("messages");
  const svgElement = document.getElementById("svg");
  const backgroundsElement = document.getElementById("backgrounds");

  // If anything does throw, these are the values we'll use
  const color_error = "#E00000";
  const text_error = `<span class='error'>error</span>`;

  // Some derived values for layout
  var gaps = []; // gap[i] is the extra padding above message i, where 0=no padding and 1=1 line of padding
  var pos = []; // pos[i] = {left, top, width, height, cx, cy} for message i
  var idmap = {}; // a map {id -> [i1, i2]}, but only listing ones that pass the filter

  // Here we compute 'gaps' derived values, the extra padding above messages.
  // The idea is that messages-with-time go first in the list. If at least three messages
  // have times, then we'll set up the 'gap' array to scale their positions.
  var time_count = messages.findIndex((m) => m.time == null);
  time_count = time_count == -1 ? messages.length : time_count;
  if (time_count >= 3) {
    const earliest_time = messages[0].time;
    const latest_time = messages[time_count - 1].time;
    // Imagine N=time_count messages spread over a vertical axis according to their
    // timestamp, where the vertical axis is 4N tall. This implies the natural "y"
    // of each element, and hence the natural separation between two elements.
    // We will cap the separation into the range [1..5], and define gap=separation-1.
    const yrange = time_count * 4; // 4N
    const timerange = latest_time.getTime() - earliest_time.getTime();
    gaps[0] = 0;
    for (var i = 1; i < time_count; i++) {
      const prev_natural_y =
        ((messages[i - 1].time.getTime() - earliest_time.getTime()) /
          timerange) *
        yrange;
      const natural_y =
        ((messages[i].time.getTime() - earliest_time.getTime()) / timerange) *
        yrange;
      var separation = natural_y - prev_natural_y;
      separation = Math.max(Math.min(separation, 5), 1);
      gaps[i] = separation - 1;
    }
  }
  // Let's place a gap of 4 between messages-with-time and those without,
  // and then all messages-without-time will be adjacent to each other.
  for (var i = time_count; i < messages.length; i++) {
    gaps[i] = i == time_count && i != 0 ? 4 : 0;
  }
  // If every single element was spaced out, we might as well compress them.
  const mingap = Math.min(...gaps.slice(1, time_count - 1));
  for (var i = 1; i < time_count; i++) {
    gaps[i] -= mingap;
  }

  // Render phase 1: this inserts html into messagesElement, and computes pos[] and idmap[]
  var html = "";
  for (var i = 0; i < messages.length; i++) {
    const m = messages[i];
    const align = align_fn(m);
    var text;
    try {
      text = esc(text_fn(m));
    } catch (e) {
      text_exn ||= e;
      text = text_error;
    }
    var id;
    try {
      id = id_fn(m);
      id = id == null ? null : String(id);
    } catch (e) {
      id_exn ||= e;
      id = id_error;
      color = color_error;
    }
    var color;
    try {
      color = hsl((hash(String(color_fn(m))) % 12) / 12.0, 0.5, 0.9);
    } catch (e) {
      color_exn ||= e;
      color = color_error;
    }
    if (m.filter === null) color = color_error; // if there had been errors computing its filter_fn
    // derived quantities pos[] and idmap[]
    pos[i] = { cx: align == "right" ? 380 : align == "left" ? 20 : 200 };
    if (id != null) {
      if (idmap[id] == null) idmap[id] = [];
      idmap[id].push(i);
    }
    // produce the html for this message
    var time = "";
    if (m.time != null) {
      var time = formatTime(m.time);
      time = `<span class='messagetime'>${
        align == "right" ? "&nbsp;" : ""
      }${time}${align == "right" ? "" : "&nbsp;"}</span>`;
    }
    var time_right = align == "right" ? time : "";
    var time_left = align == "right" ? "" : time;
    const gap = gaps[i] == 0 ? "" : `margin-top: ${gaps[i] * 3}ex;`;
    const s = `<div class="message" style='text-align: ${align}; ${gap}' data-color='${color}'><span class="messageall">${time_left}<span class="messagetext">${text}</span>${time_right}</span></div>`;
    html += s;
  }
  messagesElement.innerHTML = html;

  // Render phase 2: uses the message elements that have been created to obtain
  // layout information, set up handlers on them, and completes pos[]
  for (var i = 0; i < messages.length; i++) {
    const element = messagesElement.children[i];
    const message = messages[i];
    const gindex = message.gindex;
    const textspan = element.getElementsByClassName("messagetext")[0]; // should definitely be there
    const timespan = element.getElementsByClassName("messagetime")[0]; // may not be there
    textspan.addEventListener("click", (event) =>
      message_handler(event, element, gindex)
    );
    timespan?.addEventListener("click", (event) =>
      time_handler(event, message.time)
    );
    timespan?.addEventListener("contextmenu", (event) => {
      event.preventDefault();
      time_handler(event, message.time);
    });
    pos[i] = {
      left: element.offsetLeft,
      top: element.offsetTop,
      width: element.offsetWidth,
      height: element.offsetHeight,
      cx: pos[i].cx,
      cy: element.offsetTop + element.offsetHeight / 2,
    };
  }

  // Render phase 3: update svg, which contains the lines.
  // The svg element will have "width=100% height=<natural_height>" to fill entire space.
  // The viewbox will have "width=400 height=<natural_height>"
  // so that coordinates of elements will be normalized to an X range [0..400]
  // and a Y range identical to the pixel positions of the elements
  const lastChild = messagesElement.lastChild;
  const height =
    lastChild == null ? 0 : lastChild.offsetTop + lastChild.offsetHeight;
  svgElement.setAttribute("height", height);
  svgElement.setAttribute("viewBox", `0 0 400 ${height}`);
  // Now assemble the content of the svg, i.e. the id lines
  var svg = "";
  for (const [id, indexes] of Object.entries(idmap)) {
    if (indexes.length <= 1) continue;
    const color = hsl((hash(id) % 12) / 12.0, 0.9, 0.4);
    for (var vi = 0; vi < indexes.length - 1; vi++) {
      const m1 = indexes[vi];
      const m2 = indexes[vi + 1];
      svg += `<line x1='${pos[m1].cx}' y1='${pos[m1].cy}' x2='${pos[m2].cx}' y2='${pos[m2].cy}' stroke='${color}'/>`;
    }
    for (var vi = 0; vi < indexes.length; vi++) {
      const m1 = indexes[vi];
      svg += `<ellipse cx='${pos[m1].cx}' cy='${pos[m1].cy}' rx='1' ry='2' fill='${color}'/>`;
    }
  }
  svgElement.innerHTML = svg;

  // As for backgrounds, they're not done here; they're all provided lazily
  // by render_missing_backgrounds. That's because assembling a load of html
  // is the bottleneck, and we don't want to do more of it than necessary
  backgroundsElement.innerHTML = "";

  return { text_exn, id_exn, color_exn };
}

/** Generate any needed background divs that (lazily) were deferred
 * until they scrolled into view.
 */
function render_missing_backgrounds() {
  const container = document.getElementById("messages");
  // let's bisect to find the first child visible in the viewport
  // i.e. the first element whose bottom is > 0
  var ifirst = 0;
  var ilast = container.childElementCount;
  while (ilast - ifirst > 1) {
    const i = Math.floor((ifirst + ilast) / 2);
    const r = container.children[i].getBoundingClientRect();
    if (r.bottom > 0) ilast = i;
    else if (r.bottom <= 0) ifirst = i;
  }
  for (var i = ifirst; i < container.childElementCount; i++) {
    const element = container.children[i];
    const r = element.getBoundingClientRect();
    if (r.top > container.offsetHeight) return;
    const color = element.getAttribute("data-color");
    if (color == null) continue;
    element.removeAttribute("data-color", null);
    const span = element.children[0];
    html = `<div class='background' style='position:relative; width:100%; height:0; margin:0; top:${element.offsetTop}px; text-align:${element.style.textAlign};'><span style='display:inline-block; width:${span.offsetWidth}px; height:${span.offsetHeight}px; background-color:${color};'></span></div>`;
    document
      .getElementById("backgrounds")
      .insertAdjacentHTML("beforeend", html);
  }
}

/** Either hides the details-popup (if given null) or renders
 * the message in 'global_messages[global_popup_message_index]'
 * and attaches it to the messageDiv.
 * Note: this function reads the url query parameters for the code
 * to generate details; this query parameters were previously
 * written by control_handler.
 */
function render_popup(messageDiv) {
  // close the existing popup if necessary
  render_error(document.getElementById("error_details"), null);
  document.getElementById("popup").style.display = "none";
  if (messageDiv == null) return;
  // recompute the new popup value
  const params = new URLSearchParams(window.location.search);
  const details_fn = make_fn(params.get("details") || "message");
  var details_exn = null;
  var details;
  try {
    details = details_fn(global_messages[global_popup_message_index]);
  } catch (e) {
    details = String(e);
    details_exn = e;
  }
  if (details == null) return;
  // render the popup
  if (details_exn == null) popup.innerText = details;
  else
    popup.innerHTML = `<span class="error">${esc(String(details_exn))}</span>`;
  popup.style.display = "block";
  var { x, y } = boundPopup(
    popup,
    messageDiv.getElementsByClassName("messagetext")[0],
    messageDiv.style.textAlign
  );
  const rMessagesDiv = document
    .getElementById("messages")
    .getBoundingClientRect();
  y -= rMessagesDiv.top;
  popup.style.left = `${x}px`;
  popup.style.top = `${y}px`;
  // Update error if necessary
  render_error(document.getElementById("error_details"), details_exn);
}

/* Reads current controls. Returns a URLSearchParams with the following keys:
 * log_<name>_checked:bool, log_<name>_align:left|right|center, filter,start,end,text,id,color,details:string
 */
function read_controls() {
  var params = new URLSearchParams();
  const filter = document.getElementById("input_filter").value;
  const start = document.getElementById("input_start").value;
  const end = document.getElementById("input_end").value;
  const text = document.getElementById("input_text").value;
  const id = document.getElementById("input_id").value;
  const color = document.getElementById("input_color").value;
  const details = document.getElementById("input_details").value;
  if (filter != defaults.filter) params.set("filter", filter);
  if (start != defaults.start) params.set("start", start);
  if (end != defaults.end) params.set("end", end);
  if (text != defaults.text) params.set("text", text);
  if (id != defaults.id) params.set("id", id);
  if (color != defaults.color) params.set("color", color);
  if (details != defaults.details) params.set("details", details);
  for (const div of document.getElementsByClassName("log")) {
    const checkboxElement = div.getElementsByTagName("input")[0];
    const alignElement = div.getElementsByTagName("select")[0];
    const key = div.getAttribute("id"); // e.g. "log_client"
    const value = checkboxElement.checked
      ? alignElement.value
      : "hide_" + alignElement.value; // e.g. "left" or "hide_center"
    const def = key == "log_server" ? defaults.log_server : defaults.log;
    if (value == def) continue;
    params.set(key, value);
  }
  return params;
}

/** Writes a URLSearchParams into the UI controls
 */
function write_controls(params) {
  const write = (element, paramName, def) => {
    element.value = params.has(paramName) ? params.get(paramName) : def;
  };
  write(document.getElementById("input_filter"), "filter", defaults.filter);
  write(document.getElementById("input_start"), "start", defaults.start);
  write(document.getElementById("input_end"), "end", defaults.end);
  write(document.getElementById("input_text"), "text", defaults.text);
  write(document.getElementById("input_id"), "id", defaults.id);
  write(document.getElementById("input_color"), "color", defaults.color);
  write(document.getElementById("input_details"), "details", defaults.details);
  for (const div of document.getElementsByClassName("log")) {
    const checkboxElement = div.getElementsByTagName("input")[0];
    const alignElement = div.getElementsByTagName("select")[0];
    const key = div.getAttribute("id"); // e.g. "log_client"
    const def = key == "log_server" ? defaults.log_server : defaults.log;
    const value = params.has(key) ? params.get(key) : def;
    const checked = !value.startsWith("hide_");
    var align = value.startsWith("hide_") ? value.substring(5) : value;
    if (!["left", "center", "right"].includes(align)) align = "left";
    checkboxElement.checked = checked;
    alignElement.value = align;
  }
}

/** Adds a new log dropdown. 'checked' says whether it will be initially checked.
 * 'align' is left/right/center. 'count' is a number to show to its right.
 */
function append_log_control(log, checked, align, count) {
  const name = log == null ? "null" : log;
  var html = "";
  html += `<td class="td_logleft" >`;
  html += `<input id='logcheck_${name}' onchange='control_handler(event)' type='checkbox' ${
    checked ? "checked" : ""
  }/>`;
  html += `<label for='logcheck_${name}'>${name}</label> <span class='logcount'>${count.toLocaleString()}</span></td>`;
  html += `<td class="td_logright"><select id='logalign_${name}' onchange='control_handler(event)'>`;
  html += `<option value="left" ${
    align == "left" ? "selected" : ""
  }>L</option>`;
  html += `<option value="center" ${
    align == "center" ? "selected" : ""
  }>C</option>`;
  html += `<option value="right" ${
    align == "right" ? "selected" : ""
  }>R</option>`;
  html += `</select></td>`;
  const table = document.getElementById("logs_table");
  const tr = table.insertRow(table.rows.length);
  tr.className = "log";
  tr.id = `log_${name}`;
  tr.innerHTML = html;
}

/**
 * Reads through the 'global_messages' to see what logs-controls should be shown,
 * reads the UI to see what log-controls are already shown,
 * and adds to the UI any log-controls that are needed. Picks sensible 'align' defaults
 * for them too.
 * Note: the log controls include the filter/alignment section and the time section.
 */
function render_controls() {
  // What log controls do we want to show?
  var logs = {}; // map from logname to number of messages in that log
  var logs_order = []; // ordered list of lognames
  for (const m of global_messages) {
    if (logs[m.log] == null) {
      logs[m.log] = 0;
      logs_order.push(m.log);
    }
    logs[m.log] += 1;
  }
  // Add in whichever ones aren't already shown
  for (const log of logs_order) {
    if (document.getElementById(`logcheck_${log}`) != null) continue;
    append_log_control(
      log,
      logs[log] < 2000,
      log == "server" ? "right" : "left",
      logs[log]
    );
  }
  // What time controls do we want to show?
  var endtimes = {};
  var earliest = null;
  var latest = null;
  for (const m of global_messages) {
    if (endtimes[m.log] == null)
      endtimes[m.log] = { earliest: null, latest: null };
    if (m.time == null) continue;
    if (earliest == null || m.time < earliest) earliest = m.time;
    if (latest == null || m.time > latest) latest = m.time;
    if (endtimes[m.log].earliest == null || m.time < endtimes[m.log].earliest)
      endtimes[m.log].earliest = m.time;
    if (endtimes[m.log].latest == null || m.time > endtimes[m.log].latest)
      endtimes[m.log].latest = m.time;
  }
  if (earliest == null) {
    document.getElementById("time").style.display = "none";
    return;
  }
  document.getElementById("time").style.display = "block";
  var startOptions = `<option></option><option value='${formatTime(
    earliest,
    "full"
  )}''>${formatTime(earliest, "full")}</option>`;
  var endOptions = `<option></option><option value='${formatTime(
    latest,
    "full"
  )}''>${formatTime(latest, "full")}</option>`;
  endOptions += `<option value='+5s'>+5s</option><option value='+10 minutes'>+10 minutes</option>`;
  for (const log of logs_order) {
    startOptions += `<option value='${formatTime(
      endtimes[log].earliest,
      "full"
    )}'>${formatTime(endtimes[log].earliest, "full")} - ${log}</option>`;
    endOptions += `<option value='${formatTime(
      endtimes[log].latest,
      "full"
    )}'>${formatTime(endtimes[log].latest, "full")} - ${log}</option>`;
  }
  document.getElementById("select_start").innerHTML = startOptions;
  document.getElementById("select_end").innerHTML = endOptions;
}

// ===================================================================
// ===================================================================
// ===================================================================
// ===================================================================
// LOGIC
// ===================================================================
// ===================================================================
// ===================================================================
// ===================================================================

const defaults = {
  filter: "",
  start: "",
  end: "",
  text: "title",
  id: "id",
  color: "title",
  details: "message",
  log: "left",
  log_server: "right",
};

/** Returns a filtered+sorted list of messages to display.
 * source:message[]' is a list of messages.
 * 'filter_fn:m->bool' is a predicate on messages.
 * 'start:Date?' and 'end:Date?' are times.
 * Returns {messages: message[], filter_exn}
 * Each message returned actually has an additional property 'gindex',
 * for the index into the source list, and some have 'filter' if
 * the filter function failed on them.
 */
function filter_and_sort_messages(source, filter_fn, start, end) {
  var filter_exn = null;

  // We'll stable-sort all messages by time, but putting unstamped messages at the end.
  // We also add a property 'gindex' to the messages in our local 'messages' array,
  // for the index into the global messages list, and an optional property
  // 'filter' which has value null for everything that couldn't be filtered.
  var messages = global_messages
    .map((m, gindex) => {
      var filter;
      try {
        filter = filter_fn(m);
      } catch (e) {
        filter_exn ||= e;
        filter = null;
      }
      if (filter === true) return { ...m, gindex };
      return { ...m, gindex, filter };
    })
    .filter((m) => {
      if (start != null && (m.time == null || m.time < start)) return false;
      if (end != null && (m.time == null || m.time > end)) return false;
      if (m.filter === false) return false;
      return true;
    });
  messages.sort((a, b) =>
    a.time == null && b.time == null
      ? 0
      : b.time == null
      ? -1
      : a.time == null
      ? 1
      : a.time < b.time
      ? -1
      : b.time < a.time
      ? 1
      : 0
  );
  return { messages, filter_exn };
}

/**
 * We are given the non-null string name of the log we're currently processing,
 * and the time of the previous log entry (may be null of no previous entries
 * in this log had a time), and a list of non-blank lines followed by blank lines.
 * If the first line doesn't start with '[' then we must have been given trivia
 * and so return null.
 */
function parse_message(log, prev_time, lines) {
  // Cleanup: if we're given a message which doesn't start with [, it must have been the initial preamble, so we delete it.
  // Cleanup: if our message ends in newlines, we'll remove them.
  // Cleanup: if we don't even have anything left, we'll skip.
  while (lines.slice(-1)[0] == "") {
    lines.pop();
  }
  if (lines.length == 0 || lines[0].charAt(0) != "[") {
    return null;
  }

  const message = lines.join("\n");

  // Gather an initial contiguous sequence of "tags".
  // A tag is something enclosed with square brackets, with optional whitespace after the closing square bracket,
  // that doesn't itself contain any brackets or braces or parentheses.
  // We strip leading and trailing whitespace from tags.
  var s = lines[0];
  var tags = [];
  while (true) {
    const match = s.match(/^\[ *([^\]\{\}\(\)]+)\] */);
    if (!match) break;
    tags.push(match[1].replace(/ *$/, ""));
    s = s.slice(match[0].length);
  }

  const line = s;

  // The optional "title" is a series of alphanumerics without punctuation
  var title = null;
  {
    const match = s.match(/^ *([A-Za-z0-9_][^:'"\{/\[\()]*)([:'"\{\[/\()]) */);
    if (match) {
      title = match[1].replace(/ *$/, "");
      s = s.slice(match[0].length);
      if (match[2] != ":") {
        s = match[2] + s;
      }
    } else {
      const match2 = s.match(/^ *([A-Za-z0-9_][^:'"\{/\[\()]*)$/);
      if (match2) {
        title = match2[1].replace(/ *$/, "");
        s = "";
      }
    }
  }

  var body = s;

  // Can we extract any filenames out of the rest of the line?
  var filename = null;
  {
    const match = (" " + s).match(/([ '"])(\/[0-9A-Za-z/_.]*)/);
    if (match) {
      filename = match[2].split("\\").pop().split("/").pop();
    }
  }

  // Can we extract json from the rest of the line plus all subsequent lines?
  var json = null;
  {
    // attempt 1: start json at the first { we see on the first line, plus all subsequent lines
    var ji = s.indexOf("{");
    if (ji != -1) {
      try {
        json = JSON.parse(s.slice(ji) + "\n" + lines.slice(1).join("\n"));
      } catch (e) {}
    }
    // attempt 2: start json at the first [ we see (after tags) on the first line, plus all subsequent lines
    ji = s.indexOf("[");
    if (json == null && ji != -1) {
      try {
        json = JSON.parse(s.slice(ji) + "\n" + lines.slice(1).join("\n"));
      } catch (e) {}
    }
    // attempt 3: look only on subsequent lines
    if (json == null) {
      try {
        json = JSON.parse(lines.slice(1).join("\n"));
      } catch (e) {}
    }
  }

  // Does one of the tags look like a timestamp? or have the form "...#..."?
  // We'll turn tags from a list into an object, with a member 'anon' for an
  // array of the unrecognized ones.
  // Note: we'll discard the year-and-date part of it entirely, so that if we're
  // mixing LSP logs (which lack year-and-date) with other logs (which have them)
  // then they'll still lign up.
  var time = null;
  var id = null;
  var oldtags = tags;
  var tags = { positional: [] };
  for (const tag of oldtags) {
    const match_time =
      tag.match(/\d\d\d\d-\d\d-\d\d (\d\d):(\d\d):(\d\d).(\d\d\d)/) ||
      tag.match(/(\d\d):(\d\d):(\d\d).(\d\d\d)/) ||
      tag.match(/\d\d\d\d-\d\d-\d\d (\d\d):(\d\d):(\d\d)/) ||
      tag.match(/(\d\d):(\d\d):(\d\d)/);
    if (match_time) {
      const h = parseInt(match_time[1]);
      const m = parseInt(match_time[2]);
      const s = parseInt(match_time[3]);
      const ms = parseInt(match_time[4] || "0");
      time = new Date(Date.UTC(1970, 0, 1, h, m, s, ms));
    } else {
      const match_id = tag.match(/^([A-Za-z]*)#.*$/);
      if (match_id) {
        if (match_id[1] == "") {
          id = tag;
        } else {
          tag[match_id[1]] = tag;
          id ||= tag;
        }
      } else {
        tags.positional.push(tag);
      }
    }
  }

  // LSP messages have a peculiar format.
  {
    const match = lines[0].match(
      /^\[Trace - (?<h>\d+):(?<m>\d+):(?<s>\d+) (?<pm>(AM|PM))\] (?<dir>(Sending|Received)) request '(?<method>.*) - \((?<id>\d*)\)'$/
    );
    if (match) {
      const h = parseInt(match.groups.h) + (match.groups.pm == "AM" ? 0 : 12);
      const m = parseInt(match.groups.m);
      const s = parseInt(match.groups.s);
      time = new Date(Date.UTC(1970, 0, 1, h, m, s));
      log = match.groups.dir == "Sending" ? "client" : "server";
      title = match.groups.method; // e.g. 'textDocument/didChange'
      const lsp_id = match.groups.id; // this includes id of notifications
      body = "";
      json = lines
        .slice(1)
        .join("\n")
        .replace(/^(Result|Params): /, "");
      try {
        json = JSON.parse(json);
      } catch (e) {
        json = null;
      }
      // for id, we'll pick up only request/response/cancellation IDs, and prefix them by whether the ID was synthesized on sender or receiver
      const kind =
        json?.id == null
          ? "notification"
          : json.result != null || json.error != null
          ? "response"
          : "request";
      tags = { kind, lsp_id };
      var originate_by_client = log == "client" ? true : false;
      if (kind == "response") originate_by_client = !originate_by_client;
      id =
        title == "$/cancelRequest"
          ? String(json?.params?.id)
          : json?.id == null
          ? null
          : String(json?.id);
      id = id == null ? null : originate_by_client ? id : `s#${id}`;
      // for file, heuristic is to pick either params.textDocument.uri, or the first didWatcheFilesChanged filename
      const change0 =
        json?.params?.changes?.length > 0 ? json?.params?.changes[0] : null;
      const uri =
        json?.params?.textDocument?.uri || json?.params?.uri || change0?.uri;
      filename = uri?.split("\\").pop().split("/").pop();
    }
  }

  // As discussed above, we discarded the year-and-date part of the timestamp (if present).
  // To handle wraparound at midnight, we'll say that if a subsequent message
  // is earlier that the previous one, then it must be one day ahead.
  while (time != null && prev_time != null && time < prev_time) {
    time.setUTCDate(time.getUTCDate() + 1);
  }
  time = time || prev_time;

  return {
    log,
    message,
    tags,
    time,
    line,
    title,
    body,
    id,
    filename,
    json,
  };
}

/**
 * Given the name of a logfile we're processing, and its content,
 * parse it into a list of messages and return that list.
 */
function parse_log(log, lines) {
  // A log's text is a series of "messages" with trivia between them.
  // A message is defined as starting on a line whose first character
  // is "[", followed by a series of non-blank lines which themselves
  // don't start with "[".
  var messages = [];
  var prev_time = null;
  var acc = [];
  for (const line of lines) {
    if (line.charAt(0) == "[") {
      const m = parse_message(log, prev_time, acc);
      prev_time = m?.time || prev_time;
      messages.push(m);
      acc = [];
    }
    acc.push(line);
  }
  const m = parse_message(log, prev_time, acc);
  prev_time = m?.time || prev_time;
  messages.push(m);
  // Filter out all cases where parse_message return null for it just being trivia
  messages = messages.filter((m) => m != null);
  // Invariant: starting from the first message to have a parseable timestamp,
  // it and all subsequent messages have monotonically ascending timestamps,
  // and none of the earlier ones do, and prev_time is the timestamp of the last message.
  // We'll use that fact to backfill the timestamp-less messages if possible:
  for (const m of messages) {
    if (m.time == null) m.time = prev_time;
  }
  // Invariant: either every message has a timestamp, or none of them do.
  return messages;
}

/** Given a list of messages, constructs and returns an autocomplete dictionary for it.
 *  Example: this list of messages
 *   [log1] foo {addr: 'hello', age: 47, cols: [1,2,3]}
 *   [log2] bar {addr: 'world', age: 53, cols: []}
 *   [log3] baz {addr: 'there', cols: []}
 * produces this dictionary:
 * { title: { hint:[string], nested: null},
 *   json: { hint:[object], nested: {
 *     addr: { hint:[string], nested:null},
 *     age: { hint:[num|undefined], nested:null},
 *     cols: [hint:[array], nested: {ELEMENT: {hint:[num],nested:null}}
 * }
 */
function build_dictionary(messages) {
  // We'll first construct everything 'positively' from the members that are present
  var dictionary = {};
  if (messages.length == 0) return dictionary;
  var add;
  add = (dict, prop, value, allowRecurse) => {
    if (dict[prop] == null) dict[prop] = { hint: new Set(), nested: null };
    var type;
    if (value === null) type = "null";
    else if (value === "") type = "empty_string";
    else if (value instanceof Date) type = "Date";
    else type = typeof value;
    if (Array.isArray(value)) {
      if (dict[prop].nested == null) dict[prop].nested = {};
      for (const v of value) {
        add(dict[prop].nested, "ELEMENT", v, true);
      }
    } else if (type == "object") {
      if (allowRecurse) {
        if (dict[prop].nested == null) dict[prop].nested = {};
        for (const [k, v] of Object.entries(value)) {
          add(dict[prop].nested, k, v, true);
        }
      }
    } else {
      dict[prop].hint.add(type);
    }
  };
  for (const m of messages) {
    for (const [k, v] of Object.entries(m)) {
      add(dictionary, k, v, k == "json" || k == "tags");
    }
  }

  // Now sprinkly in 'undefined' for members that aren't always present
  var undef;
  undef = (dict, value) => {
    if (value == null || typeof value != "object") value = {};
    for (const [k, v] of Object.entries(dict)) {
      if (k == "ELEMENT") {
        if (!Array.isArray(value)) {
          v.hint.add("undefined");
        } else if (dict["ELEMENT"].nested != null) {
          for (const e of value) {
            undef(dict["ELEMENT"].nested, e);
          }
        }
      } else {
        if (!value.hasOwnProperty(k)) v.hint.add("undefined");
        if (v.nested != null) undef(dict[k].nested, value[k]);
      }
    }
  };
  for (const m of messages) {
    undef(dictionary, m);
  }

  // Now combine all those 'primitive' hints into a hint, and provide extra hints for the top level
  var hintify;
  hintify = (dict) => {
    for (const [k, v] of Object.entries(dict)) {
      var types = [...v.hint];
      if (v.nested != null) {
        if (v.nested.hasOwnProperty("ELEMENT")) {
          types.push("array");
          if (Object.entries(v.nested).length > 1) types.push("object");
        } else {
          types.push("object");
        }
      }
      v.hint = types.length == 0 ? "none" : types.join(" | ");
      if (v.nested != null) hintify(v.nested);
    }
  };
  hintify(dictionary);
  dictionary.log.hint +=
    '  -- which logfile it came in; for lsp is "client / server"';
  dictionary.message.hint += "  -- the entire message";
  dictionary.tags.hint +=
    "  -- a list of any [...] tags at the start of the message, other than time-like ones";
  dictionary.time.hint +=
    "  -- one of the timelike [...] tag from the start of the message";
  dictionary.line.hint +=
    "  -- the first line of the message, after all the tags";
  dictionary.title.hint +=
    '  -- if line had the form "title: body" then this is the title';
  dictionary.body.hint +=
    "  -- this is however much of line after the title has been removed";
  dictionary.id.hint +=
    "  -- best-guess as to the most important id; for lsp cancellation the id being cancelled";
  dictionary.filename.hint +=
    "  --  best-guess as to an (unqualified) filename found in the message";
  dictionary.json.hint +=
    "  -- best-guess if the end of the message looked like json object or array";
  return dictionary;
}

// ===================================================================
// ===================================================================
// ===================================================================
// ===================================================================
// HELPERS
// ===================================================================
// ===================================================================
// ===================================================================
// ===================================================================

/** Given a filename like "/foo/bar/fred.txt" returns "fred"
 */
function logname_from_filepath(filepath) {
  const filename = filepath.split("\\").pop().split("/").pop();
  const extension = filename.lastIndexOf(".");
  if (extension >= 3 && extension < filename.length - 3)
    return filename.substring(0, extension);
  return filename;
}

/** Given a string, renders it suitable for html e.g. `<p>${esc(s)}</p>`
 */
function esc(s) {
  if (s == null) return "&nbsp;";
  return String(s)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&apos;");
}

/** Given a Date object, returns either just the hh:mm:ss 'compact' format for use in the messages pane,
 * or returns hh:mm:ss (+Ndays) 'full' format in the time selector
 */
function formatTime(time, style) {
  const pad2 = (s, n) => {
    s = String(s);
    while (s.length < (n || 2)) s = "0" + s;
    return s;
  };
  var hms = `${pad2(time.getUTCHours())}:${pad2(time.getUTCMinutes())}:${pad2(
    time.getUTCSeconds()
  )}`;
  const plusDays = time.getUTCDate() - 1;
  var ms = time.getUTCMilliseconds();
  if (style !== "full") return hms;
  if (ms != 0) hms += `.${pad2(ms, 3)}`;
  if (plusDays == 0) return hms;
  return `${hms} +${plusDays}day${plusDays == 1 ? "" : "s"}`;
}

/** Given a string, parses it into a time. This is recognized:
 *   null/empty string -> returns null
 *   hh:mm:ss(.mmm])? (+Ndays)?
 * If a Date object "relativeTo" is provided then a few additional formats are recognized.
 *   +N s(econds)?|m(inutes)?|h(ours)?
 * If the string can't be parsed, throw a descriptive exception
 */
function parseTime(time, relativeTo) {
  if (time == null || time == "") return null;
  if (time.match(/^\d/)) {
    const match = time.match(
      /^(\d+):(\d+):(\d+)(\.(\d\d\d))? ?(\+(\d+) ?days?)?$/
    );
    if (!match) throw new Error("expected h:m:s.mmm");
    const h = parseInt(match[1]),
      m = parseInt(match[2]),
      s = parseInt(match[3]);
    const ms = match[5] == null ? 0 : parseInt(match[5]);
    const n = match[7] == null ? 0 : parseInt(match[7]);
    return new Date(Date.UTC(1970, 0, n + 1, h, m, s, ms));
  } else if (time.charAt(0) == "+" || time.charAt(0) == "-") {
    const match = time.match(
      /^(\+|-)(\d+) ?(s|sec|secs|second|seconds|m|min|mins|minute|minutes|h|hour|hours)$/
    );
    if (!match) throw new Error("expected +N h|m|s");
    if (relativeTo == null) throw new Error("need start for +N relative times");
    const n = parseInt(match[2]) * (time.charAt() == "+" ? 1 : -1);
    const unit = match[3].charAt(0);
    const r = new Date(relativeTo.getTime());
    if (unit == "s") r.setUTCSeconds(r.getUTCSeconds() + n);
    else if (unit == "m") r.setUTCMinutes(r.getUTCMinutes() + n);
    else if (unit == "h") r.setUTCHours(r.getUTCHours() + n);
    else throw new Error("unexpected time unit");
    return r;
  } else {
    throw new Error(`expected h:m:s or +N h|m|s`);
  }
}

/** Given a string, produces a hash number
 */
function hash(s) {
  var hash = 0,
    i,
    chr;
  for (i = 0; i < s.length; i++) {
    hash = ((hash << 5) - hash + s.charCodeAt(i)) | 0;
  }
  return hash;
}

/** Given a string like "id + title", this returns a function which
 * takes message 'm' and returns the result of evaluating the string
 * If there are errors constructing the function, e.g. parse errors,
 * they're not reported immediately; instead we return a function which
 * will throw that error. In this way parse errors are produced lazily
 * just like evaluation errors.
 */
function make_fn(expr) {
  try {
    const fn = Function(
      "log",
      "message",
      "tags",
      "time",
      "line",
      "title",
      "body",
      "id",
      "filename",
      "json",
      "return " + expr
    );
    return (m) =>
      fn(
        m.log,
        m.message,
        m.tags,
        m.time,
        m.line,
        m.title,
        m.body,
        m.id,
        m.filename,
        m.json
      );
  } catch (e) {
    return (m) => {
      throw e;
    };
  }
}

/** Given hue, saturation, lightness each in range [0..1],
 * returns an rgb string "#rrggbb" for that color.
 */
function hsl(h, s, l) {
  var r, g, b;
  if (s == 0) {
    r = g = b = l;
  } else {
    const f = (p, q, t) => {
      if (t < 0) t += 1;
      else if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      else if (t < 1 / 2) return q;
      else if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      else return p;
    };
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = f(p, q, h + 1 / 3);
    g = f(p, q, h);
    b = f(p, q, h - 1 / 3);
  }
  const x = (i) => {
    var s = Math.round(i * 255).toString(16);
    while (s.length < 2) s = "0" + s;
    if (s.length > 2) s = "FF";
    return s;
  };
  return `#${x(r)}${x(g)}${x(b)}`;
}

  </script>
</head>

<body onclick='hide_popups_handler(event)'>
  <div id="left">
    <div id="title">
      <table>
        <tr>
          <td><b><a href="https://github.com/ljw1004/seaoflogs/blob/main/README.md">Sea of logs</a></b></td>
          <td>
            <label for="load" id="loadbutton">Load...</label>
            <input type="file" id="load" onchange='load_button_handler(event)' />
          </td>
        </tr>
      </table>
      <hr />
    </div>
    <div id="logs">
      <table id="logs_table"></table>
      <hr />
    </div>
    <div id="time">
      <table>
        <tr>
          <td>Start</td>
          <td>
            <input id="input_start" style="width: 6em;" onfocus="this.select()" oninput='control_handler(event)'
              type="text">
            <select id="select_start" style="width: 2.5ex;"
              onchange="document.getElementById('input_start').value=this.options[this.selectedIndex].value;control_handler(event);"></select>
          </td>
        </tr>
        <tr>
          <td>End</td>
          <td>
            <input id="input_end" style="width: 6em;" onfocus="this.select()" oninput='control_handler(event)'
              type="text">
            <select id="select_end" style="width: 2.5ex;"
              onchange="document.getElementById('input_end').value=this.options[this.selectedIndex].value;control_handler(event);"></select>
          </td>
      </table>
      <div class="error" id="error_time" style="display: none;"></div>
      <hr />
    </div>
    <div id="filter">
      Filter<br />
      <textarea id="input_filter" wrap='soft' type='text' oninput='control_handler(event)'
        onclick='autocomplete_handler(event)' onkeyup='autocomplete_handler(event)'
        onfocus='autocomplete_handler(event)'></textarea>
      <div class="error" id="error_filter" style="display: none;"></div>
      <hr />
    </div>
    <div id="text">
      Text<br />
      <textarea id="input_text" wrap="soft" type='text' oninput='control_handler(event)'
        onclick='autocomplete_handler(event)' onkeyup='autocomplete_handler(event)'
        onfocus='autocomplete_handler(event)'>title</textarea>
      <div class="error" id="error_text" style="display: none;"></div>
      <hr />
    </div>
    <div id="color">
      Color<br />
      <textarea id="input_color" wrap="soft" type='text' oninput='control_handler(event)'
        onclick='autocomplete_handler(event)' onkeyup='autocomplete_handler(event)'
        onfocus='autocomplete_handler(event)'>title</textarea>
      <div class="error" id="error_color" style="display: none;"></div>
      <hr />
    </div>
    <div id="id">
      Id<br />
      <textarea id="input_id" wrap="soft" type='text' oninput='control_handler(event)'
        onclick='autocomplete_handler(event)' onkeyup='autocomplete_handler(event)'
        onfocus='autocomplete_handler(event)'>id</textarea>
      <div class="error" id="error_id" style="display: none;"></div>
      <hr />
    </div>
    <div id="details">
      Details<br />
      <textarea id="input_details" wrap="soft" type='text' oninput='control_handler(event)'
        onclick='autocomplete_handler(event)' onkeyup='autocomplete_handler(event)'
        onfocus='autocomplete_handler(event)'>message</textarea>
      <div class="error" id="error_details" style="display: none;"></div>
      <hr />
    </div>
  </div>
  <div id="right">
    <div id="backgrounds">
    </div>
    <div id="connectors">
      <svg id="svg" width="100%" height="100" viewbox="0 0 400 100" preserveAspectRatio="none"></svg>
    </div>
    <div id="messages">
      <pre id="loading">Loading...</pre>
    </div>
  </div>
  <div id="popup"></div>
  <div id="menu"></div>
</body>
</html>
<!--
